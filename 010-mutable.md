# 🦀 Rust 변수 선언 정리
## 🔒 기본은 불변 (immutable)
```rust
let x = 5;
x = 6; // ❌ 컴파일 에러
```

- let으로 선언한 변수는 기본적으로 불변입니다.
- 값을 변경하려고 하면 컴파일 에러가 발생합니다.
- 이는 안전성과 예측 가능성을 높이기 위한 Rust의 철학입니다.
## 🔓 가변 변수 (mutable)
```rust
let mut x = 3;
x = 7; // ✅ 가능
```

- mut 키워드를 붙이면 변수의 값을 변경할 수 있습니다.
- mut는 변수 자체가 가변이라는 뜻이지, 그 안의 데이터 구조가 가변이라는 뜻은 아닙니다.

## 🧠 왜 불변이 기본일까?
Rust는 **병행성(concurrency)**과 **메모리 안전성(memory safety)**을 중요하게 생각합니다.
불변성을 기본으로 하면 다음과 같은 장점이 있어요:
- 데이터 경쟁(race condition)을 줄임
- 코드의 의도를 명확하게 표현
- 예기치 않은 변경을 방지

## 🧾 C++의 mutable과의 차이점
| 항목                     | Rust                                      | C++                                         |
|--------------------------|-------------------------------------------|---------------------------------------------|
| 기본 변수 속성           | 불변 (`let`)                              | 가변                                        |
| 가변 변수 선언 방법      | `let mut`                                 | 별도 키워드 없이 기본적으로 가변            |
| 불변 객체에서의 변경     | 불가능                                    | `mutable` 키워드로 특정 멤버 변경 가능      |
| 키워드 목적              | 변수 자체를 가변으로 선언                 | `const` 객체 내에서 일부 멤버 변경 허용     |
| 사용 예시                | `let mut x = 5; x = 6;`                   | `mutable int count; void f() const { count++; }` |
| 철학적 접근              | 안전성과 명시적 변경 강조                 | 유연성과 성능 중심                          |
| 참조의 불변/가변 구분    | `&T` (불변 참조), `&mut T` (가변 참조)    | 참조 자체는 불변/가변 구분이 덜 명확         |
| 병행성에 대한 영향       | 데이터 경쟁 방지에 유리                   | 병행성 제어는 개발자 책임                   |

## 💡 C++의 mutable 예시
```cpp
class Example {
    mutable int counter;
public:
    void increment() const {
        counter++; // const 함수에서도 변경 가능
    }
};
```

- mutable은 const 함수에서도 멤버를 변경할 수 있게 해줍니다.
- Rust에는 이런 방식이 없고, 불변 참조와 가변 참조를 명확히 구분합니다.

## ✨ 요약
- Rust는 불변이 기본, 변경하려면 mut 명시
- C++은 가변이 기본, mutable은 const 객체에서 예외적으로 사용
- Rust는 명시적이고 안전한 코드를 지향하며, C++은 유연성과 성능을 중시

---

