# Smart Pointer
Rust의 Smart Pointer 개념체계적으로 정리.

🧠 기본 개념: 포인터 vs 스마트 포인터

| 항목               | 포인터                                      | 스마트 포인터                                               |
|--------------------|---------------------------------------------|--------------------------------------------------------------|
| 정의               | 메모리 주소를 담고 있는 변수                | 포인터처럼 작동하지만 메타데이터와 기능을 포함한 구조체      |
| 대표 예시          | `&T`, `*const T`, `*mut T`                  | `Box<T>`, `Rc<T>`, `RefCell<T>`, `Arc<T>`                    |
| 소유권             | 없음 (빌림만 가능)                         | 대부분 소유권을 가짐                                         |
| 메모리 해제        | 수동 또는 참조자 스코프 종료 시 자동       | `Drop` 트레잇으로 커스터마이징 가능                          |
| 참조자처럼 사용 가능| 기본적으로 가능                             | `Deref` 트레잇을 통해 참조자처럼 동작                        |
| 기능 확장성        | 제한적                                     | 내부 가변성, 참조 카운팅, 동적 디스패치 등 다양한 기능 제공  |



## 🧰 스마트 포인터의 핵심 특징
- 일반적으로 구조체로 구현됨
- Deref 트레잇을 구현하여 참조자처럼 동작 가능
- Drop 트레잇을 구현하여 스코프 종료 시 자동 정리 가능
- 참조자(&T)는 빌림만 가능하지만, 스마트 포인터는 소유권을 가질 수 있음

## 🔍 Deref 트레잇 예제 분석
```rust
use std::ops::Deref;

struct DerefExample<T> {
    _value: T,
}

impl<T> Deref for DerefExample<T> {
    type Target = T;
    fn deref(&self) -> &Self::Target {
        &self._value
    }
}

fn main() {
    let x = DerefExample { _value: 5 };
    assert_eq!(*x, 5);           // *x → x.deref() → &5
    assert_eq!(x.deref(), &5);   // 직접 deref 호출
}
```



- *x는 자동으로 Deref 트레잇을 호출하여 &x._value로 변환됨
- 이 덕분에 스마트 포인터는 참조자처럼 자연스럽게 사용될 수 있음

## 📦 주요 스마트 포인터 종류

| 스마트 포인터   | 설명                                                                 |
|------------------|----------------------------------------------------------------------|
| `Box<T>`         | 값을 힙에 저장하고, 스택에는 포인터만 남김. 재귀 타입이나 큰 데이터에 적합 |
| `Rc<T>`          | 참조 카운팅을 통해 복수의 소유자를 허용. 단일 스레드 환경에서 사용         |
| `RefCell<T>`     | 내부 가변성을 제공. 런타임에 빌림 규칙을 검사하며 `borrow()`로 접근         |
| `Arc<T>`         | `Rc<T>`의 멀티스레드 버전. 원자적 참조 카운팅으로 스레드 간 안전한 공유 가능 |



## 🧪 예시: Box를 활용한 재귀 타입
```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}
```

- Box<List>를 사용함으로써 **무한 크기 에러(E0072)**를 피할 수 있음
- Box는 고정된 크기의 포인터이므로 컴파일러가 타입 크기를 추론 가능


## ✅ 스마트 포인터 핵심 요약

| 항목               | 설명                                                             |
|--------------------|------------------------------------------------------------------|
| 포인터             | 메모리 주소만 가짐. 참조자(`&T`)는 빌림만 가능                   |
| 스마트 포인터      | 포인터 + 메타데이터 + 기능 (소유권, 자동 해제 등)                |
| Deref 트레잇       | 스마트 포인터를 참조자처럼 사용할 수 있게 해줌                   |
| Drop 트레잇        | 스코프 종료 시 자동 정리 로직을 커스터마이징 가능                 |
| 주요 타입          | `Box<T>`, `Rc<T>`, `RefCell<T>`, `Arc<T>`                         |


