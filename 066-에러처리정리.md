# 에러 처리 정리
Rust의 에러 처리에서 핵심이 되는 Result 타입에 대해 마지막으로 깔끔하게 정리.
이건 Rust를 실무에서 안정적으로 쓰기 위한 기초이자 필수 개념입니다.

## 🧩 Result<T, E>란?
Rust의 Result는 성공 또는 실패를 표현하는 열거형(enum)입니다.
```rust
enum Result<T, E> {
    Ok(T),   // 성공 시 T 타입의 값
    Err(E),  // 실패 시 E 타입의 에러 정보
}
```

- T: 성공 시 반환할 값의 타입
- E: 실패 시 반환할 에러 타입

## 🛠️ 실전 예제 ① — 값 반환하는 함수
```rust
fn divide(numerator: i32, denominator: i32) -> Result<i32, String> {
    if denominator == 0 {
        return Err(String::from("denominator cannot be zero!"));
    }
    Ok(numerator / denominator)
}
```

- divide(10, 0) 호출 시 → Err("denominator cannot be zero!")
- divide(10, 2) 호출 시 → Ok(5)
```rust
match divide(10, 0) {
    Ok(val) => println!("value = {}", val),
    Err(msg) => println!("error = {}", msg),
}
```


## 🛠️ 실전 예제 ② — 반환값이 없는 함수 (Result<(), E>)
```rust
fn check_command_valid(cmd: &str) -> Result<(), String> {
    match cmd {
        "good" => Ok(()),
        "unsupported" => Err("Unsupported command".to_owned()),
        "bad" => Err("Bad command".to_owned()),
        _ => Err("Unknown command".to_owned()),
    }
}
```

- Result<(), E>는 성공 여부만 판단할 때 사용
- Ok(())는 "성공했지만 반환값은 없음"을 의미
```rust
match check_command_valid("good") {
    Ok(_) => println!("success"),
    Err(msg) => println!("message = {msg}"),
}
```


## 🧠 to_owned()의 역할
- 문자열 리터럴 "text"는 &str 타입 → 소유권 없음
- to_owned()를 사용하면 String 타입으로 변환 → 소유권 획득
```rust
let s: String = "hello".to_owned(); // &str → String
```

이는 Err("Bad command".to_owned())처럼 Result에 소유 가능한 에러 메시지를 넣을 때 꼭 필요합니다.

## ✨ 핵심 요약
| 항목             | 설명                                 |
|------------------|--------------------------------------|
| `Result<T, E>`   | 성공(`Ok`) 또는 실패(`Err`)를 표현하는 열거형 |
| `Ok(T)`          | 성공 시 반환되는 값                   |
| `Err(E)`         | 실패 시 반환되는 에러 정보             |
| `Result<(), E>`  | 반환값 없이 성공 여부만 판단할 때 사용 |
| `match`          | `Result`를 직접 분기 처리할 때 사용    |
| `?` 연산자       | 에러를 간결하게 호출자에게 전파         |
| `to_owned()`     | `&str` → `String`으로 소유권 획득       |

---

