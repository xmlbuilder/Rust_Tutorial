# Rust 재귀 호출 + 메모이제이션
이 코드는 **재귀 호출 + 메모이제이션(memoization)**을 활용한 Rust 스타일의 피보나치 함수 구현.
Rust의 스택 안전성과 가변 참조 처리까지 잘 고려된 구조.


🧠 핵심 개념 요약
| 구성 요소       | 설명                                      |
|----------------|-------------------------------------------|
| `_fib(n)`      | 재귀적으로 피보나치 수를 계산하는 내부 함수 |
| `cache`        | 이미 계산된 값을 저장하는 메모이제이션 벡터 |
| `&mut Vec<u32>`| 가변 참조로 `cache`를 전달하여 값 추가 가능 |
| `n`            | 계산할 피보나치 항의 인덱스 값             |



## ✅ 코드 구조 설명
```rust
fn fib(n: u32) -> u32 {
    fn _fib(n: u32, cache: &mut Vec<u32>) -> u32 {
        if n < cache.len() as u32 {
            cache[n as usize] // 이미 계산된 값 반환
        } else {
            let result = _fib(n - 1, cache) + _fib(n - 2, cache); // 재귀 호출
            cache.push(result); // 결과 저장
            result
        }
    }

    let mut cache = vec![0, 1]; // 초기값 설정
    _fib(n, &mut cache)
}
```

- fib(n)은 내부 함수 _fib(n, &mut cache)를 호출
- _fib은 cache를 참조하여 이미 계산된 값이면 바로 반환
- 아니라면 n-1, n-2를 재귀적으로 호출하고 결과를 cache에 저장

## 🧪 실행 결과
```rust
fn main() {
    println!("{}", fib(10)); // 출력: 55
}
```

- fib(10)은 피보나치 수열의 10번째 항을 계산
- 결과는 55이며, 중복 계산 없이 빠르게 처리됨

## 🛠️ 개선 아이디어 (선택 사항)
1. Vec<u32> 대신 HashMap<u32, u32> 사용
- 더 유연한 인덱싱 가능
- 특히 n이 큰 경우, sparse 계산에 유리
2. u32 → usize로 통일
- Vec 인덱싱은 usize이므로, 변환 생략 가능
3. fib을 반복문으로 구현 (재귀 제거)
- 스택 오버플로우 방지
- 성능 최적화


# Smart Pointer & 멀티스레드
Rust의 Smart Pointer를 활용한 캐시 공유와 멀티스레드 환경에서 병렬 피보나치 계산을 정리. 이 두 주제는 Rust의 메모리 안전성과 동시성 철학을 깊이 이해하는 데 아주 중요한 포인트.

## 🧠 1. Smart Pointer를 활용한 캐시 공유
Rust에서 여러 스코프나 스레드에서 데이터를 공유하려면 소유권과 참조의 제약을 해결해야 합니다. 이를 위해 사용하는 것이 바로 Smart Pointer입니다.
## ✅ 핵심 개념
| Smart Pointer | 설명                                                                 |
|---------------|----------------------------------------------------------------------|
| `Rc<T>`       | 단일 스레드에서 여러 소유자가 존재할 수 있도록 참조 카운팅           |
| `Arc<T>`      | 멀티스레드 환경에서 안전하게 참조 카운팅 (Atomic Reference Counting) |
| `RefCell<T>`  | 단일 스레드에서 런타임에 내부 가변성 허용 (`borrow_mut`, `borrow`)   |
| `Mutex<T>`    | 멀티스레드에서 데이터에 대한 안전한 가변 접근을 제공 (`lock`)         |

### 🧪 예시: Arc<Mutex<Vec<u32>>>로 캐시 공유
```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let cache = Arc::new(Mutex::new(vec![0, 1]));

    let handles: Vec<_> = (2..10).map(|n| {
        let cache = Arc::clone(&cache);
        thread::spawn(move || {
            let mut cache = cache.lock().unwrap();
            let val = cache[n - 1] + cache[n - 2];
            cache.push(val);
        })
    }).collect();

    for h in handles {
        h.join().unwrap();
    }

    let cache = cache.lock().unwrap();
    println!("{:?}", *cache); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
}
```

- Arc로 여러 스레드에 소유권 공유
- Mutex로 안전한 가변 접근
- lock()으로 접근 시점에 동기화

## 🧵 2. 멀티스레드 환경에서 병렬 피보나치 계산
Rust에서는 병렬 계산을 위해 std::thread, rayon, 또는 tokio 같은 라이브러리를 사용.
피보나치 계산은 재귀적이기 때문에 fork-join 방식으로 병렬화할 수 있습니다.

### ✅ 예시: rayon::join을 활용한 병렬 피보나치
```rust
use rayon::join;

fn fib_parallel(n: u64) -> u64 {
    if n <= 1 {
        return n;
    }

    let (a, b) = join(|| fib_parallel(n - 1), || fib_parallel(n - 2));
    a + b
}

fn main() {
    let result = fib_parallel(30);
    println!("fib(30) = {}", result); // 832040
}
```

- rayon::join은 두 작업을 병렬로 실행
- 재귀 깊이에 따라 스레드가 많아질 수 있으므로 작은 n에선 오히려 느릴 수 있음
- 병렬화는 coarse-grained 작업에 적합
⚠️ 주의점
- 병렬 피보나치는 계산량이 많지 않아 오버헤드가 성능을 떨어뜨릴 수 있음
- 실전에서는 동적 프로그래밍 방식이나 fast doubling 알고리즘이 더 효율적

### 📦 요약표
| 기술                     | 목적                          | 실전 사용 예시                    |
|--------------------------|-------------------------------|-----------------------------------|
| `Arc<Mutex<T>>`          | 멀티스레드에서 안전한 공유     | 캐시 공유, 상태 동기화            |
| `rayon::join`            | 병렬 재귀 계산                 | 피보나치, 병렬 분할 정복          |
| `Rc<RefCell<T>>`         | 단일 스레드에서 공유 + 가변성 | GUI 상태 관리, 트리 구조          |
| `Mutex<T>`               | 스레드 간 가변 접근            | 로그 버퍼, 공유 리소스            |

---
# rayon
rayon은 Rust에서 데이터 병렬 처리를 아주 쉽게 구현할 수 있게 해주는 라이브러리.


## ⚙️ Rayon 설정 단계
### 1️⃣ Cargo.toml에 의존성 추가
```
[dependencies]
rayon = "1.11"
```

- 최신 버전은 Rayon GitHub 또는 docs.rs에서 확인 가능

### 2️⃣ rayon::prelude::* 임포트
```rust
use rayon::prelude::*;
```

- 이 한 줄로 par_iter(), par_sort(), map, filter, sum 등 병렬 반복자 기능을 사용할 수 있어요
- ParallelIterator, IndexedParallelIterator 트레이트들이 자동으로 scope에 들어옵니다

### 3️⃣ 병렬 반복자 사용 예시
```rust
fn main() {
    let nums = vec![1, 2, 3, 4, 5];
    let squared_sum: i32 = nums
        .par_iter() // 병렬 반복자
        .map(|x| x * x)
        .sum();

    println!("Sum of squares: {}", squared_sum);
}
```

- par_iter()는 iter()의 병렬 버전
- 내부적으로 Rayon이 작업을 스레드에 분배하고 병렬로 실행

## 🧵 고급 설정 (선택 사항)
### ✅ 커스텀 스레드 풀 만들기
```rust
use rayon::ThreadPoolBuilder;

fn main() {
    let pool = ThreadPoolBuilder::new()
        .num_threads(4)
        .build()
        .unwrap();

    pool.install(|| {
        let result: i32 = (1..1000).into_par_iter().sum();
        println!("Sum: {}", result);
    });
}
```

- 기본적으로 Rayon은 글로벌 스레드 풀을 사용하지만, 직접 풀을 만들 수도 있어요
- install()은 해당 풀에서 병렬 작업을 실행


## ✅ Rayon 설정 요약

| 단계               | 설명                                         |
|--------------------|----------------------------------------------|
| `Cargo.toml` 설정  | `rayon = "1.11"` 추가                         |
| `use rayon::prelude::*` | 병렬 반복자 트레이트 자동 임포트             |
| `par_iter()` 사용   | 병렬 반복자 시작 (`map`, `filter`, `sum` 등) |
| 커스텀 스레드 풀    | `ThreadPoolBuilder`로 직접 풀 구성 가능       |


---

## 🧠 .into_par_iter()를 쓰는 이유

| 항목                     | 설명                                                              |
|--------------------------|-------------------------------------------------------------------|
| `.into_iter().into_par_iter()` | 일반 반복자를 병렬 반복자로 변환 (명시적 변환 방식)                  |
| `.into_par_iter()`       | 컬렉션에서 직접 병렬 반복자를 생성 (소유권 이동 기반)              |
| `map`, `filter`, `sum`   | 병렬 반복자에서 사용 가능한 어댑터들 (병렬로 실행되어 성능 향상 가능) |


## ✅ 비교: `.iter()` vs `.into_iter()` vs `.into_par_iter()`

| 메서드             | 소유권 이동 | 병렬 처리 가능 | 반환 타입             | 사용 목적                     |
|--------------------|-------------|----------------|------------------------|-------------------------------|
| `.iter()`          | ❌          | ❌             | `&T` 또는 `&&T`        | 읽기 전용 반복자 (참조 기반) |
| `.into_iter()`     | ✅          | ❌             | `T` 또는 `&T`          | 값 기반 반복자 (소유권 이동) |
| `.into_par_iter()` | ✅          | ✅             | `T`                    | 병렬 반복자 (소유권 기반)     |


## 🧪 예시
```rust
use rayon::prelude::*;

fn main() {
    let nums = vec![1, 2, 3, 4, 5];

    let sum: i32 = nums
        .into_par_iter() // 병렬 반복자 생성
        .map(|x| x * x)
        .sum(); // 병렬로 누적합 계산

    println!("Sum of squares: {}", sum); // 출력: 55
}
```

- .into_par_iter()는 nums의 소유권을 가져오고 병렬로 처리
- .par_iter()는 참조 기반 병렬 반복자 (소유권 유지)

## ⚠️ 주의할 점
- .into_par_iter()는 소유권을 가져가기 때문에 이후에 원본 컬렉션을 사용할 수 없어요
- 병렬 처리의 성능 이점은 작업량이 충분히 클 때만 나타나요 (작은 벡터는 오히려 느릴 수 있음)


---

## 🔍 par_iter() vs into_par_iter() 차이

| 메서드             | 소유권 이동 | 반환 타입 | 병렬 처리 방식       | 사용 목적                     |
|--------------------|-------------|-----------|------------------------|-------------------------------|
| `par_iter()`       | ❌          | `&T`      | 참조 기반 병렬 처리     | 원본을 유지하며 읽기 전용 처리 |
| `into_par_iter()`  | ✅          | `T`       | 값 기반 병렬 처리       | 소유권을 넘겨 병렬로 값 처리   |



## ✅ 예시 비교
### par_iter() – 참조 기반
```rust
let nums = vec![1, 2, 3, 4, 5];
let squared_sum: i32 = nums
    .par_iter()
    .map(|x| x * x)
    .sum();
```

- nums는 이후에도 사용 가능
- x는 &i32 타입

### into_par_iter() – 소유권 기반
```rust
let nums = vec![1, 2, 3, 4, 5];
let squared_sum: i32 = nums
    .into_par_iter()
    .map(|x| x * x)
    .sum();
```

- nums는 이후에 사용 불가
- x는 i32 타입

## 🧠 언제 어떤 걸 써야 할까?
- 참조만 필요하고 원본을 유지해야 한다면 → par_iter()
- 소유권을 넘겨도 되고 값 기반으로 처리하고 싶다면 → into_par_iter()
둘 다 병렬 반복자를 생성하지만, 데이터 접근 방식이 다르기 때문에
실전에서는 데이터의 생명주기와 처리 방식에 따라 선택하는 게 중요해요.



