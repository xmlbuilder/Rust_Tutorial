# Statement/Expression

Rust는 표현식 중심(expression-oriented) 언어입니다.  
이 말은 대부분의 코드가 **값을 생성하는 식(expression)**으로 구성된다는 뜻이에요.  
반면, **명령문(statement)**은 어떤 동작을 수행하지만 값을 반환하지 않죠.

## 🧠 Statement vs Expression

| 구분        | 설명                                                                 | 세미콜론 `;` 여부 |
|-------------|----------------------------------------------------------------------|-------------------|
| Statement   | 어떤 동작을 수행하지만 값을 반환하지 않음. 변수 선언, 함수 호출 등     | 있음              |
| Expression  | 평가되어 값이 생성됨. 다른 식에 포함되거나 반환값으로 사용 가능         | 없음 (마지막 줄) |



## ✅ 예제 비교
❌ Statement를 값처럼 사용하면 오류
```rust
fn main() {
    let x = (let y = 6); // ❌ 컴파일 오류
}
```        

- let y = 6은 statement이므로 값을 반환하지 않음.
- 따라서 x에 바인딩할 수 있는 값이 없어 오류 발생.

## ✅ Expression 블록 사용
```rust
fn main() {
    let y = {
        let x = 3;     // statement
        5 + x          // expression → y에 8이 바인딩됨
    };

    println!("y = {y}"); // 출력: y = 8
}
```


- 중괄호 {}는 블록 표현식으로 간주됨.
- 마지막 줄 5 + x는 세미콜론 없이 표현식으로 평가되어 y에 저장됨.

## 📦 Statement vs Expression의 장단점

| 항목       | 장점                                                                 | 단점                                                                 |
|------------|----------------------------------------------------------------------|----------------------------------------------------------------------|
| Statement  | - 명령 수행에 명확함<br>- 변수 선언, 제어 흐름 등 구조적 역할        | - 값을 반환하지 않음<br>- 표현식처럼 사용할 수 없음                  |
| Expression | - 대부분의 코드가 값으로 평가됨<br>- 함수, 블록, 조건문 등에서 유연함 | - 세미콜론 실수 시 오류 발생 가능<br>- 초보자에게 개념이 혼동될 수 있음 |


## 🔍 Rust에서 표현식이 쓰이는 곳
- let x = { ... }; → 블록의 마지막 표현식이 x에 바인딩됨
- if, match, loop, while 등도 표현식으로 사용 가능
- 함수의 마지막 줄도 표현식으로 반환 가능
```rust
fn add(a: i32, b: i32) -> i32 {
    a + b // 표현식 반환
}
```
---





