# 소유권 복사
Rust에서 소유권이 복사되는 경우를 정리해드릴게요.  
핵심은 값이 스택에 저장되는 기본형 타입은 소유권이 아니라 값 자체가 복사되기 때문에 자유롭게 사용할 수 있다는 점.

## 🧠 기본형 타입과 소유권 복사
Rust에서는 다음과 같은 **기본형 타입(primitive types)**은 Copy 트레잇이 자동으로 구현되어 있어서, 변수 간 대입 시 소유권이 이동하지 않고 값이 복사됩니다:
```rust
let x = 3;
let y = x; // x는 여전히 유효함
println!("x = {x}, y = {y}");
```

## ✅ 복사 가능한 기본형
| 타입 종류     | 예시           |
|---------------|----------------|
| 정수 타입     | `u32`, `i64`, `usize` 등 |
| 부울 타입     | `bool` (`true`, `false`) |
| 문자 타입     | `char`         |
| 부동소수점     | `f32`, `f64`   |


➡️ 이들은 모두 스택에 저장되며, 복사 시 소유권 문제가 발생하지 않아요.

## 🧩 튜플의 경우
튜플도 내부에 있는 값들이 모두 Copy 가능한 타입이면, 튜플 전체가 복사 가능합니다.
```rust
let a = (1, true); // (i32, bool) → 모두 Copy
let b = a;         // 복사됨 → a도 여전히 사용 가능
```

하지만 튜플 안에 String처럼 힙에 저장되는 타입이 포함되면, 소유권 이동이 발생합니다:
```rust
let a = (1, String::from("hi")); // (i32, String)
let b = a; // a는 더 이상 사용 불가
```

➡️ String은 Copy가 아닌 Clone을 사용해야 복사 가능

## 📋 요약 표
| 값의 구성                | 복사 가능 여부 | 소유권 이동 여부 | 예시                      |
|--------------------------|----------------|------------------|---------------------------|
| `i32`, `bool`            | ✅ 가능         | ❌ 없음           | `let x = 3; let y = x;`   |
| `(i32, bool)`            | ✅ 가능         | ❌ 없음           | `let a = (1, true);`      |
| `(i32, String)`          | ❌ 불가능       | ✅ 이동됨         | `let a = (1, String::from("hi"));` |

----



