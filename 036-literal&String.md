# 리터럴과 스트링
Rust의 문자열 타입인 &str과 String에 대한 핵심 개념.

## 🧠 문자열 리터럴 vs String 타입
### 🔹 &str (문자열 슬라이스)
- **불변(immutable)**이며, 컴파일 시점에 크기가 고정됨
- 스택에 저장된 문자열 리터럴을 참조하는 형태
- 프로그램 실행 중 변경 불가
- 빠르고 효율적
```rust
let x = "Hello"; // &str 타입
```

➡️ "Hello"는 프로그램에 고정된 메모리에 저장되고, x는 그 위치를 참조함

### 🔸 String (소유하는 문자열)
- **가변(mutable)**이며, 런타임에 크기가 결정됨
- 힙에 메모리 할당되어 저장됨
- 문자열을 추가하거나 수정 가능
- 소유권과 drop에 따라 메모리 자동 해제
```rust
let mut s = String::from("Hello");
s.push_str(", World!");
println!("{s}"); // Hello, World!
```

➡️ String은 힙에 저장되므로 크기 변경이 자유롭고, 소유권에 따라 메모리 관리됨

## 🧩 실전 예제 요약
```rust
fn main() {
    let x = "Hello"; // &str, 스택에 저장된 리터럴 참조
    println!("x = {x}");

    let mut s = String::from("Hello"); // 힙에 저장된 String
    s.push_str(", World!");
    println!("s = {s}");
}


fn main() {
    let hello = String::from("안녕하세요");
    let slice = &hello[0..3]; // 부분 참조
    println!("slice - {slice}"); // 안
    println!("0 th char {}", hello.chars().nth(0).unwrap()); // 안
}
```


## 🧭 메모리 구조 비교
| 구분         | &str (문자열 리터럴)                  | String (소유하는 문자열)               |
|--------------|----------------------------------------|----------------------------------------|
| 저장 위치    | 스택에서 참조                         | 힙에 직접 저장                         |
| 크기         | 고정                                   | 가변                                   |
| 변경 가능 여부 | ❌ 불변                                | ✅ 변경 가능                            |
| 메모리 할당  | 컴파일 시점                            | 런타임 시점                            |
| 소유권       | 없음 (참조만 함)                       | 있음 (drop 시 메모리 해제됨)           |
| 사용 예시    | `"Hello"`                              | `String::from("Hello")`                |



## 📚 정리
- &str: 스택에 저장된 리터럴을 참조하는 타입
- String: 힙에 메모리를 할당받아 소유하는 타입
- String::new(), .to_string(), String::from() 등 다양한 생성 방식
- 소유권이 필요한 경우 String, 값만 필요할 경우 &str 사용

----


# hello.chars().nth(0).unwrap()
복잡해 보이는 표현을 쓰는 이유는 문자열이 UTF-8로 인코딩되어 있기 때문이에요.  
Rust는 안전성과 성능을 중시하기 때문에, 문자열을 단순히 배열처럼 다루는 걸 허용하지 않음.

## 🧵 왜 chars().nth(0)인가?
Rust의 문자열(String 또는 &str)은 UTF-8 인코딩을 따르기 때문에, 각 문자가 1~4 바이트로 표현될 수 있어요.  
예를 들어:
- "a"는 1바이트
- "안"은 3바이트
따라서 hello[0]처럼 인덱스로 접근하면 바이트 단위로 처리되기 때문에, 멀티바이트 문자를 잘못 읽을 수 있어요.  
그래서 Rust는 문자 단위 접근을 위해 .chars()라는 메서드를 제공하죠.
```rust
let ch = hello.chars().nth(0).unwrap();
```

- .chars() → 문자열을 문자(char) 단위로 나눠주는 이터레이터
- .nth(0) → 첫 번째 문자를 가져옴
- .unwrap() → Option<char>에서 실제 값을 꺼냄 (없으면 panic 발생)

## 🧠 왜 unwrap()까지 써야 해?
.nth(0)은 Option<char> 타입을 반환해요. 왜냐하면:
- 문자열이 비어 있을 수도 있기 때문
- 안전하게 처리하려면 Some(c)인지 None인지 확인해야 함
```rust
match hello.chars().nth(0) {
    Some(c) => println!("첫 글자: {}", c),
    None => println!("문자열이 비어 있어요!"),
}
```

➡️ unwrap()은 "무조건 값이 있다고 믿고 꺼내는" 방식이에요. 실전에서는 match나 if let으로 안전하게 처리하는 게 좋아요.

## 🐢 성능 이슈는 없을까?
사실 .chars().nth(n)는 n번째 문자까지 순차적으로 읽어야 하므로 느릴 수 있어요.  
특히 긴 문자열에서 반복적으로 사용하면 성능 저하가 생길 수 있어요.
개선 방법:
- 이터레이터를 미리 저장해서 .next()로 순차 접근
- 또는 바이트 단위로 직접 처리 (단, UTF-8 주의 필요)

## ✨ 대안 요약
| 목적                     | 추천 방식                                           | 설명                                                                 |
|--------------------------|----------------------------------------------------|----------------------------------------------------------------------|
| 첫 글자만 필요할 때      | `hello.chars().next()`                             | 가장 간단한 방법. `Option<char>` 반환                              |
| 특정 위치의 문자 접근    | `match hello.chars().nth(n)`                       | 안전하게 `Some(c)` 또는 `None` 처리 가능                           |
| 반복적으로 문자 접근     | `let mut iter = hello.chars(); iter.next()`        | 반복 처리에 적합. 이터레이터를 재사용 가능                         |
| 바이트 단위 접근         | `hello.as_bytes()`                                 | UTF-8 바이트 배열로 접근. 멀티바이트 문자 처리 시 주의 필요         |

---



