# String Parser
String을 i32로 파싱하는 예제.  
Rust에서는 다양한 숫자 타입으로도 파싱할 수 있어요. 아래에 i32, u32, f32, f64 등으로 확장한 예제와 함께 설명.

## 🧪 다양한 숫자 타입으로 파싱하기
```rust
use std::num::{ParseIntError, ParseFloatError};

fn parse_i32(input: &str) -> Result<i32, ParseIntError> {
    input.parse()
}

fn parse_u32(input: &str) -> Result<u32, ParseIntError> {
    input.parse()
}

fn parse_f32(input: &str) -> Result<f32, ParseFloatError> {
    input.parse()
}

fn parse_f64(input: &str) -> Result<f64, ParseFloatError> {
    input.parse()
}

fn main() {
    let input = "1234.56";

    // i32
    let result_i32 = parse_i32(input).unwrap_or(0);
    println!("i32 result = {}", result_i32); // 실패: 소수점 포함 -> 0

    // u32
    let result_u32 = parse_u32(input).unwrap_or(0);
    println!("u32 result = {}", result_u32); // 실패: 소수점 포함 -> 0

    // f32
    let result_f32 = parse_f32(input).unwrap_or(0.0);
    println!("f32 result = {}", result_f32); // 성공 -> 1234.56

    // f64
    let result_f64 = parse_f64(input).unwrap_or(0.0);
    println!("f64 result = {}", result_f64); // 성공 -> 1234.56
}
```


## 🔍 설명
| 타입  | 설명                     | 입력 값     | 파싱 결과   |
|-------|--------------------------|-------------|-------------|
| `i32` | 32비트 정수              | `"1234"`    | `1234`      |
| `u32` | 32비트 부호 없는 정수    | `"1234"`    | `1234`      |
| `f32` | 32비트 부동소수점        | `"1234.56"` | `1234.56`   |
| `f64` | 64비트 부동소수점        | `"1234.56"` | `1234.56`   |

- parse()는 제네릭 함수로, 원하는 타입을 명시하면 해당 타입으로 파싱 시도
- 실패할 경우 Result::Err를 반환하므로 unwrap_or()나 match로 처리 가능

## ✅ 실전 팁
- 사용자 입력을 받을 때는 항상 trim()으로 공백 제거
- 파싱 실패에 대비해 match, unwrap_or, unwrap_or_else 등을 활용
- parse::<T>()는 T: FromStr을 구현한 타입이면 모두 사용 가능

---

## 🧠 1. Enum을 사용해 타입 선택 구조 만들기
먼저 사용자가 원하는 타입을 선택할 수 있도록 enum을 정의하고, 그에 따라 파싱하는 구조를 만들어볼게요.
### ✅ 예제 코드
```rust
use std::num::{ParseIntError, ParseFloatError};

enum NumberType {
    I32,
    U32,
    F32,
    F64,
}

fn parse_number(input: &str, number_type: NumberType) {
    match number_type {
        NumberType::I32 => {
            match input.parse::<i32>() {
                Ok(n) => println!("Parsed as i32: {}", n),
                Err(e) => println!("Failed to parse as i32: {}", e),
            }
        }
        NumberType::U32 => {
            match input.parse::<u32>() {
                Ok(n) => println!("Parsed as u32: {}", n),
                Err(e) => println!("Failed to parse as u32: {}", e),
            }
        }
        NumberType::F32 => {
            match input.parse::<f32>() {
                Ok(n) => println!("Parsed as f32: {}", n),
                Err(e) => println!("Failed to parse as f32: {}", e),
            }
        }
        NumberType::F64 => {
            match input.parse::<f64>() {
                Ok(n) => println!("Parsed as f64: {}", n),
                Err(e) => println!("Failed to parse as f64: {}", e),
            }
        }
    }
}

fn main() {
    let input = "1234.56";

    parse_number(input, NumberType::I32);
    parse_number(input, NumberType::U32);
    parse_number(input, NumberType::F32);
    parse_number(input, NumberType::F64);
}
```


### 🔍 2. 자동 타입 판별 (간단한 시도)
Rust은 정적 타입 언어라서 런타임에서 자동 타입 판별은 제한적이지만, 아래처럼 우선순위 기반으로 시도:
```rust
fn auto_parse(input: &str) {
    if let Ok(n) = input.parse::<i32>() {
        println!("Parsed as i32: {}", n);
    } else if let Ok(n) = input.parse::<f64>() {
        println!("Parsed as f64: {}", n);
    } else {
        println!("Failed to parse input.");
    }
}

fn main() {
    auto_parse("1234");
    auto_parse("1234.56");
    auto_parse("abc");
}
```

### 🧠 동작 원리
- parse::<i32>() 먼저 시도
- 실패하면 parse::<f64>()로 시도
- 모두 실패하면 오류 메시지 출력


### ✅ 핵심 요약

| 항목              | 설명 |
|-------------------|------|
| `enum NumberType` | 사용자가 원하는 숫자 타입을 선택할 수 있도록 정의한 열거형 |
| `auto_parse()`    | 입력값을 기반으로 타입을 자동 판별하여 파싱 시도 |
| `parse::<T>()`    | 제네릭 파싱 함수. `T`는 `FromStr` 트레잇을 구현한 타입이어야 함 |



 문자열을 파싱할 때 float 값을 int로 자동 변환하느냐는 의미였군요. Rust에서는 이 부분도 자동 변환되지 않습니다. 문자열 "1234.56"을 i32로 파싱하려고 하면 런타임 에러가 발생해요. Rust는 타입 안정성을 지키기 위해 명시적이고 정확한 타입 지정을 요구하거든요.

### 🔍 예시: 문자열을 int로 파싱할 때 float이 들어오면?
```rust
fn main() {
    let input = "1234.56";
    let parsed: Result<i32, _> = input.parse();

    match parsed {
        Ok(n) => println!("Parsed as i32: {}", n),
        Err(e) => println!("Failed to parse: {}", e),
    }
}
```

### 🔥 출력 결과:
```rust
Failed to parse: invalid digit found in string
```

- "1234.56"은 소수점이 포함된 문자열이기 때문에 i32로 파싱할 수 없습니다.
- Rust는 자동으로 소수점을 버리고 int로 변환하지 않아요.
- 대신, f64로 먼저 파싱한 뒤 as i32로 명시적으로 변환해야 합니다.

### ✅ 올바른 방식: float → int 변환
```rust
fn main() {
    let input = "1234.56";
    let parsed_float: f64 = input.parse().unwrap_or(0.0);
    let parsed_int: i32 = parsed_float as i32;

    println!("Float: {}", parsed_float); // 1234.56
    println!("Int: {}", parsed_int);     // 1234
}
```

이렇게 하면:
- parse::<f64>()로 먼저 소수점 포함 숫자를 파싱하고
- as i32로 명시적으로 정수로 변환 (소수점은 잘림)

## 📌 핵심 요약
| 입력 문자열       | 파싱 시도 타입 | 결과            | 비고       |
|------------------|----------------|------------------|------------|
| `"1234"`         | `i32`          | ✅ 성공           | 정수로 정상 파싱 |
| `"1234.56"`      | `i32`          | ❌ 실패           | 소수점 포함 → 에러 |
| `"1234.56"` → `f64` → `i32` | `f64` → `i32` | ✅ 성공 (`1234`) | `as`로 명시적 변환 |


Rust는 이런 부분에서 암묵적인 타입 변환을 허용하지 않음으로써 버그를 줄이고, 개발자의 의도를 명확하게 표현하도록 유도.

---

## 형 전환

Rust는 C와는 다르게 타입 안정성과 명확한 의도 표현을 중시하는 언어예요.  
그래서 **double(f64)**을 **int(i32, u32 등)**로 변환할 때도 명시적인 캐스팅을 요구하고, 자동 변환은 허용하지 않음. 개발자가 직접 as 키워드를 사용해서 변환할 수 있어요.

### 🔁 Rust에서 float → int 변환 방식
fn main() {
    let float_val: f64 = 1234.56;
    let int_val: i32 = float_val as i32;

    println!("float: {}", float_val); // 1234.56
    println!("int: {}", int_val);     // 1234 (소수점 버림)
}


### 🔍 특징
- as를 사용하면 소수점 이하가 잘려나가고 정수 부분만 남아요 (trunc 방식)
- 자동 변환은 안 되고, 명시적 캐스팅만 허용
- 타입이 맞지 않으면 parse() 같은 함수는 컴파일 에러 또는 런타임 에러 발생

### ❌ Rust는 자동 변환을 하지 않음
C에서는 다음과 같은 코드가 허용되죠:
```cpp
double d = 1234.56;
int i = d; // 자동 변환
```

Rust에서는 이렇게 하면 컴파일 에러가 납니다:
```rust
let d: f64 = 1234.56;
let i: i32 = d; // ❌ 에러: 타입 불일치
``

Rust에서는 반드시 다음처럼 명시해야 해요:
```rust
let i: i32 = d as i32; // ✅ 명시적 캐스팅
```


### ✅ 더 안전한 방식: .round(), .floor(), .ceil()
```rust
let d = 1234.56;
let rounded = d.round() as i32; // 반올림
let floored = d.floor() as i32; // 내림
let ceiled  = d.ceil()  as i32; // 올림
```

이렇게 하면 의도한 방식으로 변환할 수 있어서 코드의 의미가 더 명확해져요.

##💡 요약

| 언어  | 자동 변환 | 명시적 변환 | 키워드 | 안전성 |
|--------|------------|----------------|---------|--------|
| C      | ✅         | 선택적         | 없음    | 낮음   |
| Rust   | ❌         | 필수           | `as`    | 높음   |

Rust는 개발자의 의도를 명확히 표현하도록 유도하기 때문에, 자동 변환보다는 명시적이고 안전한 방식을 선호합니다.


