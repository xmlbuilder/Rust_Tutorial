# 구조체 사용법
아래에 각 구조체의 의미와 사용 방식, 그리고 관련 개념들을 자세히 설명.

## 🧱 구조체 종류와 설명
### 1. Classic Struct (명명된 필드 구조체)
```rust
#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}
```

- 용도: 관련된 데이터를 이름과 함께 묶을 때 사용.
- 특징:
- 필드 이름이 있어 가독성이 높음.
- #[derive(Debug)]를 통해 println!("{:?}", person)으로 출력 가능.
- 소유권 주의: String 타입은 소유권을 가지므로 구조체에 넣으면 원래 변수는 소유권을 잃음.

### 2. Unit Struct (필드 없는 구조체)
```rust
struct Unit;
```

- 용도: 타입만 필요하고 데이터가 필요 없는 경우. 예: 마커 타입, trait 구현용.
- 특징: 메모리를 차지하지 않음.

### 3. Tuple Struct (필드 이름 없는 구조체)
```rust
struct Pair(i32, f32);
```

- 용도: 간단한 데이터 묶음. 튜플처럼 사용하지만 타입 이름을 부여할 수 있음.
- 접근법: pair.0, pair.1처럼 인덱스로 접근.

### 4. Nested Struct (구조체 안에 구조체)
```rust
#[derive(Debug)]
struct Point {
    x: f32,
    y: f32,
}

struct Rectangle {
    top_left: Point,
    bottom_right: Point,
}
```

- 용도: 복잡한 데이터 모델링. 예: 좌표를 이용한 사각형 표현.
- 구조체 업데이트 문법: Point { x: 5.2, ..point }는 기존 point의 y 값을 재사용.

## 🧠 주요 개념 설명
### 📌 소유권 이동
```rust
let name = String::from("Peter");
let peter = Person { name, age };
```

- name은 String 타입이므로 Person에 들어가면 소유권이 이동됨.
- 이후 name을 사용하면 컴파일 에러 발생.

### 📌 구조체 디스트럭처링
```rust
let Point { x: left_edge, y: top_edge } = point;
```

- 구조체의 필드를 변수로 분해해서 사용할 수 있음.
- left_edge, top_edge는 각각 point.x, point.y 값을 가짐.

### 📌 구조체 필드 재사용 (.. 문법)
```rust
let bottom_right = Point { x: 5.2, ..point };
```

- point의 y 값을 재사용하고 x만 새로 지정.
- 매우 유용한 문법으로, 필드 일부만 변경할 때 사용.


## ✨ 확장 아이디어
- impl 블록을 사용해 구조체에 메서드를 추가할 수 있어요:
```rust
impl Rectangle {
    fn area(&self) -> f32 {
        let width = self.bottom_right.x - self.top_left.x;
        let height = self.top_left.y - self.bottom_right.y;
        width * height
    }
}
```

- 이렇게 하면 rect.area()처럼 호출할 수 있어 객체지향적인 설계가 가능해집니다.

---
