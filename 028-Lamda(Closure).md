# Lamda (Closure)
Rust에서 **람다(클로저)**를 함수 인자로 넘길 때의 주의사항과 클로저를 사용할 때의 장점


## 기본 문법
```rust
let my_func = |x| x + 1;
println!("{}", my_func(3)); // 출력: 4
```
- 클로저는 |파라미터| 표현식 형태로 작성하며, 변수처럼 저장 가능
- 타입 명시 가능
```rust
let my_func = |x: i32| -> i32 { x + 1 };
```
- Rust는 타입을 추론하지만, 명시적으로 지정할 수도 있음

## 환경 캡처 예시
```rust
let num = 5;
let add_num = |x: i32| x + num;
```
- 외부 변수 num을 캡처하여 클로저 내부에서 사용


## 🧠 클로저를 함수 인자로 넘길 때 주의사항
Rust에서는 클로저가 **환경을 캡처(capture)**할 수 있기 때문에, 함수 인자로 넘길 때 다음 사항들을 고려해야 합니다:
| 개념              | 설명                                                                 |
|-------------------|----------------------------------------------------------------------|
| `Fn`, `FnMut`, `FnOnce` | 클로저가 환경을 어떻게 캡처하는지에 따라 구현되는 트레이트. 함수 인자 타입으로 지정 필요 |
| `move`            | 클로저가 외부 변수의 **소유권을 가져오도록** 지정. 스레드나 비동기 작업에서 자주 사용됨 |
| 타입 추론         | Rust는 클로저의 파라미터와 리턴 타입을 자동으로 추론하지만, 명시적으로 지정할 수도 있음 |
| `async` / `Future`| 비동기 클로저는 `Future`를 반환하며, `async move` 형태로 자주 사용됨 |
| `Box<dyn Fn()>`   | 클로저를 **동적 디스패치**로 처리할 때 사용. 런타임에 결정되는 클로저를 저장하거나 전달할 때 유용 |

## 🔧 예시:
```rust
fn apply<F>(f: F)
where
    F: Fn(i32) -> i32,
{
    println!("{}", f(5));
}

fn main() {
    let closure = |x| x + 1;
    apply(closure); // Fn 트레이트를 만족하므로 OK
}
```

## 🌟 클로저를 사용할 때의 장점
| 장점                     | 설명                                                                 |
|--------------------------|----------------------------------------------------------------------|
| 간결한 문법              | `|x| x + 1`처럼 함수 선언 없이 짧고 직관적으로 작성 가능               |
| 환경 캡처 가능           | 외부 변수 사용 가능 → 상태를 유지한 함수처럼 동작                      |
| 고차 함수와의 궁합       | `map`, `filter`, `unwrap_or_else` 등과 함께 사용하면 코드가 깔끔해짐   |
| 타입 추론 지원           | 컴파일러가 파라미터와 리턴 타입을 자동으로 추론해줌                    |
| 일회성 로직에 적합       | 재사용하지 않을 로직을 간단하게 처리 가능                              |

---

