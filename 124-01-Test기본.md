## 🧪 기본 테스트 모듈
Rust의 src/lib.rs 파일에 작성된 기본 단위 테스트 코드가 담겨 있습니다:
```
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
```

## ✅ 핵심 설명
- #[cfg(test)]: 이 모듈은 cargo test를 실행할 때만 컴파일됨
- mod tests: 테스트 전용 모듈 선언
- #[test]: 테스트 함수임을 표시하는 어노테이션
- assert_eq!(2 + 2, 4): 테스트 조건. 2+2가 4와 같은지 확인
즉, 이 코드는 Rust 프로젝트를 생성하면 자동으로 포함되는 기본 테스트 템플릿이며,
테스트 시스템이 정상 작동하는지 확인하는 데 사용됩니다.

## 🧠 Rust 테스트 조직화 방식
Rust는 테스트를 **단위 테스트(Unit Test)**와 **통합 테스트(Integration Test)**로 나누어 관리합니다.
### 🔹 1. 단위 테스트 (Unit Test)
- 위 이미지처럼 src/lib.rs 또는 src/main.rs 내부에 작성
- #[cfg(test)]로 컴파일 조건 설정
- mod tests 내부에 #[test] 함수들 배치
- use super::*로 상위 모듈의 함수 접근 가능

### 🔹 2. 통합 테스트 (Integration Test)
- tests/ 디렉토리 아래 별도 .rs 파일로 작성
- 각 파일은 독립적인 크레이트로 컴파일됨
- #[cfg(test)] 필요 없음
- 라이브러리의 공개 API만 테스트 가능

```
project/
├── src/
│   └── lib.rs
└── tests/
    └── integration_test.rs
```


### 🧩 테스트 조직화 전략
| 전략 항목                  | 설명                                                               |
|----------------------------|--------------------------------------------------------------------|
| `math.rs` / `math_test.rs` | 기능별로 모듈과 테스트를 분리하여 유지보수성과 가독성 향상             |
| `vec![]`                   | 테스트 테이블을 활용해 반복되는 케이스를 간결하게 처리                 |
| `tests/common/mod.rs`      | 통합 테스트에서 공통 로직(설정, 헬퍼 함수 등)을 별도 모듈로 관리        |
| `#[ignore]`, `#[should_panic]` | 느린 테스트나 실패 예상 테스트에 어노테이션을 붙여 선택적 실행 가능     |



---
