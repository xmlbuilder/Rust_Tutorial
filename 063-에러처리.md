# 에러 처리
Rust는 에러를 **복구 가능(recoverable)**과 **복구 불가능(unrecoverable)**으로 나누어 처리합니다.  
이 구조 덕분에 안정적이고 예측 가능한 프로그램을 작성할 수 있어요.

## 🧭 에러의 두 가지 종류
| 에러 종류       | 설명                                | 처리 방식       | 예시 코드 또는 메서드       |
|----------------|-------------------------------------|----------------|-----------------------------|
| 복구 가능 에러 | 프로그램이 계속 실행될 수 있음       | `Result<T, E>` | `File::open`, `match`, `?` |
| 복구 불가능 에러 | 논리적 오류, 치명적 상황으로 종료 필요 | `panic!`       | `panic!`, `unwrap()`       |



## ⚠️ 복구 불가능한 에러: panic!
```rust
fn main() {
    panic!("강제 종료!");
}
```

- 프로그램이 즉시 종료되며, stack backtrace가 출력됩니다.
- 예: v[99]처럼 존재하지 않는 인덱스 접근 시 자동으로 panic 발생
```rust
let v = vec![1, 2, 3];
println!("v[99] = {}", v[99]); // panic!
```
📌 "index out of bounds" 에러 발생.

## ✅ 복구 가능한 에러: Result<T, E>
Rust에서는 실패할 수 있는 작업(예: 파일 열기)을 Result 타입으로 감싸서 처리합니다.
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

### 예시: 파일 열기
```rust
use std::fs::File;

fn main() {
    let file_result = File::open("hello.txt");
    match file_result {
        Ok(_) => println!("파일 열기 성공"),
        Err(_) => println!("파일 열기 실패"),
    }
}
```

### 에러 종류에 따른 분기 처리
```rust
use std::io::ErrorKind;

fn main() {
    let file_result = File::open("hello.txt");
    match file_result {
        Ok(_) => println!("파일 열기 성공"),
        Err(error) => match error.kind() {
            ErrorKind::NotFound => println!("파일이 없습니다"),
            _ => println!("다른 에러 발생"),
        },
    }
}
```



## 🧪 간편한 처리: unwrap()과 expect()
### unwrap()
```rust
let file = File::open("hello.txt").unwrap(); // 파일 없으면 panic!
```

- 값이 없을 경우 panic 발생
- 디버깅이나 테스트에서는 간편하지만, 실무에서는 위험할 수 있음

### expect()
```rust
let file = File::open("hello.txt").expect("파일을 열 수 없음");
```

- unwrap()과 유사하지만, 사용자 정의 메시지를 출력
- 이미지에서도 "구체적인 패닉 메시지 출력" 예시로 등장했어요

## 🧠 정리: 언제 panic을 써야 할까?
| 상황 또는 용도               | 권장 방식            | 설명                                                  |
|-----------------------------|----------------------|-------------------------------------------------------|
| 예제 코드, 테스트 코드       | `unwrap`, `expect`   | 간단한 코드에서 빠르게 실패를 확인할 때 사용          |
| 실무 로직, 라이브러리 코드   | `Result<T, E>`       | 에러를 호출자에게 전달하여 복구 가능하게 처리         |
| 실패가 논리적으로 불가능한 경우 | `expect`             | 실패 시 사용자 정의 메시지를 포함해 명확한 오류 제공  |


예를 들어, 하드코딩된 IP 주소를 파싱할 때는 expect("유효한 IP여야 함")처럼 사용해도 괜찮습니다.


## 예제
```rust
use std::f64::consts::E;
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let file_result = File::open("hello.txt");
    match file_result {
        Ok(_) => println!("파일 열기 성공"),
        Err(error) => print!("열기 실패")
    };
}

fn main() {
    let file_result = File::open("hello.txt");
    match file_result {
        Ok(_) => println!("파일 열기 성공"),
        Err(error) => match error.kind() {
            ErrorKind::NotFound => print!("file not founded"),
            _ => print!("not founded"),
        }
    };
}

//파일을 바로 받을 수 있으나 파일이 없으면 패닉이 발생한다.
fn main() {
    let file = File::open("hello.txt").unwrap();
}
//구체적인 패닉 메시지 출력이 가능하다.
fn main() {
    let file = File::open("hello.txt").expect("파일을 열수 없음");
}

```


## 🔐 보너스: panic을 잡고 싶다면?
Rust에서는 std::panic::catch_unwind를 사용해 panic을 감지할 수 있어요:
```rust
use std::panic;

fn main() {
    let result = panic::catch_unwind(|| {
        let v = vec![1, 2, 3];
        v[99]; // panic 발생
    });

    if result.is_err() {
        println!("panic 감지됨");
    }
}
```



하지만 일반적인 로직에서는 panic을 제어 흐름으로 사용하지 않는 것이 원칙입니다.
---

