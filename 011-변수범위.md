# 🧮 Rust의 정수 타입과 범위
Rust는 정수 타입을 부호 있는(signed) 타입과 부호 없는(unsigned) 타입으로 나눕니다. 각 타입은 고정된 비트 수를 가지며, 그에 따라 표현 가능한 값의 범위가 달라집니다.
## 📊 정수 타입별 범위
| 타입    | 비트 수 | 최소값 (`MIN`)                          | 최대값 (`MAX`)                          |
|---------|---------|------------------------------------------|------------------------------------------|
| `i8`    | 8       | -128                                     | 127                                      |
| `u8`    | 8       | 0                                        | 255                                      |
| `i16`   | 16      | -32,768                                  | 32,767                                   |
| `u16`   | 16      | 0                                        | 65,535                                   |
| `i32`   | 32      | -2,147,483,648                           | 2,147,483,647                            |
| `u32`   | 32      | 0                                        | 4,294,967,295                            |
| `i64`   | 64      | -9,223,372,036,854,775,808               | 9,223,372,036,854,775,807                |
| `u64`   | 64      | 0                                        | 18,446,744,073,709,551,615               |
| `i128`  | 128     | -170,141,183,460,469,231,731,687,303,715,884,105,728 | 170,141,183,460,469,231,731,687,303,715,884,105,727 |
| `u128`  | 128     | 0                                        | 340,282,366,920,938,463,463,374,607,431,768,211,455 |


참고: i는 signed integer, u는 unsigned integer를 의미합니다.


## 🧵 변수 범위와 스코프(scope)
Rust에서 변수는 블록 {} 안에서 선언된 위치에 따라 스코프가 결정됩니다. 스코프를 벗어나면 변수는 더 이상 접근할 수 없습니다.
```rust
fn main() {
    let x = 10;
    {
        let y = 20;
        println!("x: {}, y: {}", x, y); // ✅ 가능
    }
    println!("x: {}", x); // ✅ 가능
    // println!("y: {}", y); // ❌ 오류: y는 스코프 밖
}
```

## 🧩 Bracket Escape ({{}}) 설명
Rust의 println! 매크로에서 {}는 포맷팅 자리 표시자입니다. 중괄호를 출력하고 싶다면 중괄호를 두 번 써야 합니다:
```rust
println!("This is a brace: {{ and }}");
```

## 결과:
```
This is a brace: { and }
```

## 코드에서:

```rust
println!("The smallest i8 {{{}}} and the biggest i8 is {{{}}}.", i8::MIN, i8::MAX);
```

는 다음처럼 출력됩니다:
```
The smallest i8 {-128} and the biggest i8 is {127}.
```

## 전체 소스
```rust

fn main(){

    //Bracket escape에 대해서도 알아 두어어야 한다.

    println!("The smallest i8 {{{}}} and the biggest i8 is {{{}}}.", i8::MIN, i8::MAX);
    println!("The smallest i16 is {} and the biggest i16 is {}.", i16::MIN, i16::MAX);
    println!("The smallest u16 is {} and the biggest u16 is {}.", u16::MIN, u16::MAX);
    println!("The smallest i32 is {} and the biggest i32 is {}.", i32::MIN, i32::MAX);
    println!("The smallest u32 is {} and the biggest u32 is {}.", u32::MIN, u32::MAX);
    println!("The smallest i64 is {} and the biggest i64 is {}.", i64::MIN, i64::MAX);
    println!("The smallest u64 is {} and the biggest u64 is {}.", u64::MIN, u64::MAX);
    println!("The smallest i128 is {} and the biggest i128 is {}.", i128::MIN, i128::MAX);
    println!("The smallest u128 is {} and the biggest u128 is {}.", u128::MIN, u128::MAX);
}


```
---


# 🧠 C++에서 변수 범위 확인 방법
## ✅ 1. <limits> 헤더 사용 (C++11 이상)
```cpp
#include <iostream>
#include <limits>

int main() {
    std::cout << "int 최소값: " << std::numeric_limits<int>::min() << "\n";
    std::cout << "int 최대값: " << std::numeric_limits<int>::max() << "\n";
}
```

- std::numeric_limits<T>::min() / max()를 통해 정수, 실수, 부동소수점 등 모든 타입의 범위를 확인할 수 있어요.
- C++11부터는 constexpr로도 사용 가능해져서 컴파일 타임 상수로 활용할 수 있습니다.

## 📊 C++ 정수 타입별 범위 (Markdown 표)
| 타입                  | 크기 (바이트) | 최소값                              | 최대값                              |
|-----------------------|---------------|--------------------------------------|--------------------------------------|
| `char`                | 1             | -128                                 | 127                                  |
| `unsigned char`       | 1             | 0                                    | 255                                  |
| `short`               | 2             | -32,768                              | 32,767                               |
| `unsigned short`      | 2             | 0                                    | 65,535                               |
| `int`                 | 4             | -2,147,483,648                       | 2,147,483,647                        |
| `unsigned int`        | 4             | 0                                    | 4,294,967,295                        |
| `long`                | 4 or 8        | 플랫폼에 따라 다름                   | 플랫폼에 따라 다름                   |
| `unsigned long`       | 4 or 8        | 0                                    | 플랫폼에 따라 다름                   |
| `long long`           | 8             | -9,223,372,036,854,775,808           | 9,223,372,036,854,775,807            |
| `unsigned long long`  | 8             | 0                                    | 18,446,744,073,709,551,615           |


📌 참고: long과 unsigned long의 크기는 운영체제와 컴파일러에 따라 달라질 수 있습니다. 
 Windows에서는 보통 4바이트, Linux에서는 8바이트인 경우가 많습니다.


## 🧩 추가 기능: type_traits와 concepts (C++20)
- C++20부터는 concepts를 통해 타입 제약을 걸 수 있어 범위나 타입 안정성을 더 정교하게 관리할 수 있어요.
- 예: std::integral, std::signed_integral, std::unsigned_integral 등
---


