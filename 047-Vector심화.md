# Vector 
## ⚠️ 이미지 속 에러 원인 분석: Borrow Checker
문제 코드
```rust
let first = &v[0]; // 불변 참조자 생성
v.push(6);         // 가변 참조자 발생 → 에러
println!("{}", first); // 불변 참조자 사용
```

## 에러 메시지
- error[E0502]: 이미 불변 참조자가 존재하는 상태에서 가변 참조자가 생성됨
- Rust는 동시에 불변 참조자와 가변 참조자를 허용하지 않음
- 이유: 데이터 경쟁 조건 방지. 불변 참조자가 데이터를 읽는 중에, 가변 참조자가 데이터를 바꾸면 예측 불가능한 동작이 발생할 수 있음
## 해결 방법
- 참조자 사용이 끝난 후에 .push()를 호출하거나
- 참조자 대신 값 복사 또는 소유권 이전을 사용

## 🧠 핵심 기능 발췌: Vec<T>의 실전 기능들
| 🧠 기능 범주         | 🔧 사용 예시 및 설명                                                  |
|----------------------|---------------------------------------------------------------------|
| 벡터 생성            | `Vec::new()`, `vec![...]`, `Vec::with_capacity(n)`                  |
| 타입 명시            | `Vec::<T>::new()`, `let v: Vec<T>`                                  |
| 요소 추가            | `.push(value)`                                                      |
| 요소 제거            | `.pop()`, `.remove(index)`, `.clear()`                              |
| 요소 접근            | `v[i]` (panic 가능), `v.get(i)` → `Option<&T>`                      |
| 반복 처리            | `for x in &v`, `for x in &mut v`                                    |
| 정렬 및 반전         | `.sort()`, `.reverse()`                                              |
| 슬라이스             | `&v[start..end]`                                                     |
| 용량 확인            | `.capacity()`                                                       |
| 구조체 벡터          | `Vec<Book>` 등 사용자 정의 타입 저장 가능                           |
| 필터링 및 수집       | `iter().filter().collect()`, 수동 `.push()`                          |


## 🧩 실전 패턴 요약
### 1. 구조체 벡터 선언
```rust
#[derive(Debug)]
struct Book {
    title: String,
    author: String,
    published: u32,
}

let library = vec![
    Book { title: "Rust".into(), author: "Steve".into(), published: 2023 },
    Book { title: "Other".into(), author: "Someone".into(), published: 2022 },
];
```

### 2. 필터링 함수
```rust
fn find_rust<'a>(books: &'a Vec<Book>) -> Vec<&'a Book> {
    books.iter().filter(|b| b.title.contains("Rust")).collect()
}
```

### 3. 반복문으로 수정
```rust
let mut v = vec![1, 2, 3];
for x in &mut v {
    *x += 10;
}
```


### 4. 안전한 접근
```rust
match v.get(2) {
    Some(val) => println!("값: {}", val),
    None => println!("해당 인덱스 없음"),
}
```


## 🧼 메모리 관리
- Vec<T>는 스코프를 벗어나면 자동으로 drop() 호출됨
- 구조체처럼 RAII 원칙에 따라 메모리 해제됨
- 참조자 사용 시에는 Borrow Checker가 안전성 보장

## ✅ 정리: 실전에서 주의할 점
| ✅ 주의 항목             | ⚠️ 설명 및 예시                                                  |
|--------------------------|------------------------------------------------------------------|
| 빈 벡터 타입 명시        | `Vec::new()`은 타입 추론이 불가능하므로 `Vec<i32>`처럼 명시 필요 |
| 인덱스 접근 안전성       | `v[i]`는 panic 가능, `v.get(i)`는 `Option<&T>`로 안전하게 처리 가능 |
| 구조체 벡터 활용         | `Vec<Struct>`로 복잡한 데이터 모델링 가능 (`Vec<Book>` 등)       |
| 참조자 라이프타임 관리   | `Vec<&T>`를 반환할 경우 `'a` 라이프타임 명시 필요 (`fn -> Vec<&'a T>`) |

---



## 🔍 함수 시그니처 분석
```rust
fn find_rust<'a>(books: &'a Vec<Book>) -> Vec<&'a Book>
```

각 부분의 의미
| 코드 부분             | 의미 설명                                      |
|----------------------|------------------------------------------------|
| `'a`                 | 함수 전체에서 참조자들이 공유하는 생명 주기 이름 |
| `&'a Vec<Book>`      | `books` 벡터에 대한 참조는 `'a` 생명 주기를 가짐 |
| `Vec<&'a Book>`      | 반환되는 벡터는 `'a` 생명 주기를 가진 `Book` 참조들을 담음 |



## 🧠 왜 생명 주기를 명시해야 할까?
Rust는 메모리 안전성을 보장하기 위해 참조자의 유효 범위를 컴파일 타임에 검사합니다.
이 함수는 books 벡터의 요소들을 참조해서 새로운 벡터에 담아 반환하므로,
반환된 참조들이 원래 books 벡터보다 오래 살아서는 안 됩니다.
즉, books가 살아 있는 동안만 Vec<&Book>도 유효해야 하므로,
입력과 출력 모두 'a라는 동일한 생명 주기를 공유해야 해요.

🧪 생명 주기 없으면 생기는 문제
만약 생명 주기를 명시하지 않으면, Rust는 다음과 같은 컴파일 에러를 발생시켜요:
error[E0106]: missing lifetime specifier


이건 Rust가 "반환된 참조가 얼마나 살아야 하는지 모르겠어!"라고 말하는 거예요.

## ✅ 정리
- 'a는 입력 참조자와 출력 참조자 사이의 관계를 명시
- 반환된 참조들이 입력 벡터보다 오래 살아서는 안 됨
- 생명 주기를 명시함으로써 Rust는 메모리 안전성을 보장할 수 있음

---

## 🔁 함수의 생명 주기 흐름
```rust
fn find_rust<'a>(books: &'a Vec<Book>) -> Vec<&'a Book>
```

- books는 'a 생명 주기를 가진 참조자
- 반환되는 Vec<&'a Book>도 'a 생명 주기를 가진 참조자들로 구성됨
- 즉, 반환된 참조자들은 books가 살아 있는 동안만 유효

## ⚠️ 에러가 나는 상황 예시
```rust
fn main() {
    let result;
    {
        let library = vec![/* Book들 */];
        result = find_rust(&library); // result는 library의 참조를 담고 있음
    } // library가 여기서 drop됨

    println!("{:?}", result); // ❌ 에러: result가 더 오래 살아 있음
}
```

- 위 코드에서는 library가 스코프를 벗어나면서 메모리에서 해제됨
- 그런데 result는 library의 내부 데이터를 참조하고 있으므로 dangling reference가 됨
- Rust는 이런 상황을 컴파일 타임에 에러로 잡아냄

✅ 안전한 사용 예시
```rust
fn main() {
    let library = vec![/* Book들 */];
    let result = find_rust(&library); // result는 library와 같은 스코프에 있음

    println!("{:?}", result); // ✅ 안전: library가 살아 있음
}
```

- library와 result가 같은 스코프에 있으므로 참조가 유효함
- 생명 주기 'a는 이 스코프 전체를 의미하게 됨

## 🔐 핵심 요약
| 🔐 개념               | 🧠 설명 및 의미                                                   |
|----------------------|------------------------------------------------------------------|
| `'a` 생명 주기       | 참조자의 유효 범위를 명시하는 이름. 함수 내 여러 참조자가 공유 가능 |
| 참조자의 유효 범위    | 반환값이 입력 참조자보다 오래 살아서는 안 됨                     |
| 스코프 벗어난 참조자 | 컴파일 에러 발생: `borrowed value does not live long enough`     |

---

# 🔍 <’a> 기호의 의미와 범위
## 1. 제네릭 생명 주기 파라미터
- <’a>는 함수나 구조체가 생명 주기 'a를 파라미터로 받는다는 뜻이에요.
- 마치 fn foo<T>(x: T)처럼 타입 파라미터를 받는 것과 동일한 방식으로 생명 주기도 파라미터화할 수 있어요.
## 2. 범위(scope)
- <’a>는 함수 전체 또는 구조체 정의 전체에 적용되는 생명 주기 범위를 선언합니다.
- 이 범위 안에서 'a는 모든 참조자에 공통적으로 적용되는 생명 주기 이름이 돼요.
예시:
```rust
fn example<'a>(x: &'a i32, y: &'a i32) -> &'a i32 {
    if x > y { x } else { y }
}
```

- 여기서 'a는 x, y, 그리고 반환값 모두에 적용됨
- 즉, 반환값은 x와 y 중 더 오래 살아남는 참조자와 동일한 생명 주기를 가짐

## 🧠 왜 <’a>처럼 써야 할까?
| 🧠 이유                     | 🔍 설명                                                                 |
|----------------------------|------------------------------------------------------------------------|
| 참조자 관계 명시 필요       | 여러 참조자 간의 유효 범위를 명확하게 연결하기 위해 `'a`를 선언함         |
| 반환값의 생명 주기 지정     | 반환되는 참조자가 입력 참조자보다 오래 살아남지 않도록 컴파일러가 확인 가능 |
| 자동 추론의 한계 보완       | Rust가 복잡한 참조 관계를 자동으로 추론하지 못할 때 명시적으로 지정 필요   |
| 메모리 안전성 보장          | dangling reference를 방지하고 안전한 참조자 사용을 컴파일 타임에 검증 가능  |

## 🧩 구조체에서도 사용됨
```rust
struct BookRef<'a> {
    title: &'a str,
    author: &'a str,
}
```
- 'a는 구조체 필드들에 적용되는 생명 주기
- 이 구조체의 인스턴스는 'a 생명 주기 동안만 유효함

## ✅ 정리
| ✅ 문법 요소         | 🔍 설명 및 의미                                                   |
|---------------------|------------------------------------------------------------------|
| `<’a>`              | 생명 주기 파라미터 선언. 함수나 구조체, `impl` 블록 전체에 적용됨 |
| `'a`                | 참조자의 유효 범위를 나타내는 이름. 여러 참조자 간의 관계를 명시함 |
| `impl<'a>`          | 생명 주기를 가진 구조체나 트레이트에 대해 메서드를 정의할 때 사용 |

---



## 🧱 1. 구조체에 생명 주기 적용
```rust
struct BookRef<'a> {
    title: &'a str,
    author: &'a str,
}
```

- BookRef 구조체는 'a 생명 주기를 가진 참조자들을 필드로 가짐
- 이 구조체 인스턴스는 'a 생명 주기 동안만 유효함

## 🔧 2. impl<'a> 블록에서 생명 주기 사용
```rust
impl<'a> BookRef<'a> {
    fn summary(&self) -> String {
        format!("{} by {}", self.title, self.author)
    }
}
```

- impl<'a>는 구조체의 생명 주기를 메서드 정의에 연결
- self는 'a 생명 주기를 가진 참조자들을 포함하므로, 메서드도 그 생명 주기를 따라야 함

### 🧩 3. 트레이트 정의에서 생명 주기 사용
```rust
trait Describable<'a> {
    fn describe(&self) -> &'a str;
}
```

- 트레이트가 'a 생명 주기를 파라미터로 받음
- describe 메서드는 'a 생명 주기를 가진 참조자를 반환함
구현 예시:
```rust
impl<'a> Describable<'a> for BookRef<'a> {
    fn describe(&self) -> &'a str {
        self.title
    }
}
```

- BookRef<'a>는 Describable<'a>를 구현
- 반환값은 구조체 내부의 참조자(&'a str)이므로 생명 주기를 맞춰야 함

## ✅ 정리: 언제 생명 주기를 써야 할까?
| ✅ 상황                         | 🔍 생명 주기 명시 여부 및 예시                                      |
|-------------------------------|-------------------------------------------------------------------|
| 참조자를 필드로 갖는 구조체     | ✅ 필요 → `struct Foo<'a> { x: &'a T }`                             |
| 참조자를 반환하는 메서드        | ✅ 필요 → `fn get(&self) -> &'a T`                                 |
| 트레이트에서 참조 반환         | ✅ 필요 → `trait Trait<'a> { fn f(&self) -> &'a T }`               |
| 값만 다루는 구조체/메서드      | ❌ 불필요 → `struct Foo { x: String }`                             |

---


