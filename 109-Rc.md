# Rc
Rustì˜ Rc<T> ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ì— ëŒ€í•´ ì™„ì „í•˜ê²Œ ì •ë¦¬.
ë³µìˆ˜ ì†Œìœ ê¶Œê³¼ ë°ì´í„° ê³µìœ ì˜ ê°œë…ì„ ì •ë¦¬.

## ğŸ§  Rc<T>ë€?
Rc<T>ëŠ” Reference Counted Smart Pointerì˜ ì¤„ì„ë§ë¡œ,
í•˜ë‚˜ì˜ ê°’ì„ ì—¬ëŸ¬ ì†Œìœ ìê°€ ê³µìœ í•  ìˆ˜ ìˆë„ë¡ í•´ì£¼ëŠ” Rustì˜ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ì…ë‹ˆë‹¤.

## âœ… Rc<T> vs Arc<T> í•µì‹¬ íŠ¹ì§•
| í•­ëª©               | Rc<T> (std::rc)                                | Arc<T> (std::sync)                              |
|--------------------|-----------------------------------------------|--------------------------------------------------|
| ì˜ë¯¸               | Reference Counted                             | Atomic Reference Counted                         |
| ì‚¬ìš© í™˜ê²½          | ë‹¨ì¼ ìŠ¤ë ˆë“œ                                   | ë©€í‹° ìŠ¤ë ˆë“œ                                      |
| ë‚´ë¶€ ë™ê¸°í™”        | ì—†ìŒ (ë¹ ë¦„)                                   | ìˆìŒ (ìŠ¤ë ˆë“œ ì•ˆì „, ëŠë¦¼)                         |
| ì°¸ì¡° ì¹´ìš´íŠ¸ ë°©ì‹   | ì¼ë°˜ ì¹´ìš´íŒ…                                   | ì›ìì  ì¹´ìš´íŒ… (atomic operations)               |
| ëŒ€í‘œ ìš©ë„          | ê·¸ë˜í”„, íŠ¸ë¦¬, ê³µìœ  ë¦¬ìŠ¤íŠ¸ ë“± ë‹¨ì¼ ìŠ¤ë ˆë“œ êµ¬ì¡° | ë³‘ë ¬ ì²˜ë¦¬, ìŠ¤ë ˆë“œ ê°„ ë°ì´í„° ê³µìœ                  |
| Clone ë™ì‘         | ì°¸ì¡° ì¹´ìš´íŠ¸ ì¦ê°€ë§Œ ìˆ˜í–‰                        | ì°¸ì¡° ì¹´ìš´íŠ¸ ì¦ê°€ë§Œ ìˆ˜í–‰                          |
| Drop ì‹œì           | ì°¸ì¡° ì¹´ìš´íŠ¸ê°€ 0ì´ ë˜ë©´ ìë™ ë©”ëª¨ë¦¬ í•´ì œ       | ë™ì¼í•˜ê²Œ 0ì´ ë˜ë©´ ìë™ í•´ì œ                      |


## ğŸ” Rc<T> ë™ì‘ ì˜ˆì œ
```rust
use std::rc::Rc;

fn main() {
    let origin = Rc::new(0);
    println!("Reference count: {}", Rc::strong_count(&origin)); // 1

    {
        let _dup1 = Rc::clone(&origin);
        println!("Reference count: {}", Rc::strong_count(&origin)); // 2

        {
            let _dup2 = Rc::clone(&origin);
            println!("Reference count: {}", Rc::strong_count(&origin)); // 3
        }

        println!("Reference count: {}", Rc::strong_count(&origin)); // 2
    }

    println!("Reference count: {}", Rc::strong_count(&origin)); // 1
}
```


- Rc::clone()ì€ ì°¸ì¡° ì¹´ìš´íŠ¸ë§Œ ì¦ê°€ì‹œí‚¤ê³ , ì‹¤ì œ ë°ì´í„°ëŠ” ë³µì‚¬í•˜ì§€ ì•ŠìŒ
- ìŠ¤ì½”í”„ê°€ ëë‚˜ë©´ ìë™ìœ¼ë¡œ ì°¸ì¡° ì¹´ìš´íŠ¸ê°€ ê°ì†Œë¨

## ğŸ“¦ Rc<T>ë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ 
- ê·¸ë˜í”„ êµ¬ì¡°ë‚˜ ê³µìœ  ë¦¬ìŠ¤íŠ¸ì²˜ëŸ¼ ì—¬ëŸ¬ ë…¸ë“œê°€ ê°™ì€ ë°ì´í„°ë¥¼ ì°¸ì¡°í•´ì•¼ í•  ë•Œ
- ì»´íŒŒì¼ íƒ€ì„ì— ëˆ„ê°€ ë§ˆì§€ë§‰ìœ¼ë¡œ ë°ì´í„°ë¥¼ ì‚¬ìš©í• ì§€ ì•Œ ìˆ˜ ì—†ì„ ë•Œ
- Box<T>ëŠ” ë‹¨ì¼ ì†Œìœ ê¶Œë§Œ ê°€ëŠ¥í•˜ë¯€ë¡œ, ê³µìœ ê°€ í•„ìš”í•œ ê²½ìš° Rc<T>ë¡œ ëŒ€ì²´

### ğŸ§ª ì˜ˆì œ: Rc<T>ë¥¼ ì´ìš©í•œ ë¦¬ìŠ¤íŠ¸ ê³µìœ 
```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```



- aëŠ” ë¦¬ìŠ¤íŠ¸ 5 â†’ 10 â†’ Nilì„ ê°€ë¦¬í‚´
- bì™€ cëŠ” aë¥¼ ê³µìœ í•¨ â†’ ì°¸ì¡° ì¹´ìš´íŠ¸ëŠ” 3
- aê°€ ìŠ¤ì½”í”„ë¥¼ ë²—ì–´ë‚˜ê¸° ì „ê¹Œì§€ ë©”ëª¨ë¦¬ëŠ” í•´ì œë˜ì§€ ì•ŠìŒ

### ğŸ§¬ ë°ì´í„° ê³µìœ  êµ¬ì¡° ì‹œê°í™”
```mermaid
graph TD
    A["Cons 5"] --> B["Cons 10"]
    B --> C["Nil"]

    D["Cons 3"] --> A
    E["Cons 4"] --> A
```

- A â†’ B â†’ CëŠ” ë¦¬ìŠ¤íŠ¸ a
- Dì™€ EëŠ” ê°ê° b, cì´ë©° aë¥¼ ê³µìœ í•¨
- Rc::clone()ì„ í†µí•´ Aë¥¼ ì—¬ëŸ¬ ë…¸ë“œê°€ ì°¸ì¡°

### ğŸ§ª ì˜ˆì œ: Rc<T>ë¥¼ ì´ìš©í•œ ë…¸ë“œ ê³µìœ 
```rust
struct Node {
    val: i32,
    next: Option<Rc<Node>>,
}

fn main() {
    let node1 = Rc::new(Node { val: 2, next: None });

    let head1 = Node {
        val: 1,
        next: Some(Rc::clone(&node1)),
    };

    let head2 = Node {
        val: 3,
        next: Some(Rc::clone(&node1)),
    };

    println!("{} {}", head1.val, head1.next.unwrap().val); // 1 2
    println!("{} {}", head2.val, head2.next.unwrap().val); // 3 2
}
```

- node1ì€ head1ê³¼ head2ê°€ ê³µìœ 
- ì°¸ì¡° ì¹´ìš´íŠ¸ëŠ” 3 (node1, head1.next, head2.next)


## âœ… Rc<T> ìš”ì•½

| í•­ëª©               | ì„¤ëª…                                                                 |
|--------------------|----------------------------------------------------------------------|
| ëª©ì                | í•˜ë‚˜ì˜ ê°’ì„ ì—¬ëŸ¬ ì†Œìœ ìê°€ ê³µìœ í•  ìˆ˜ ìˆë„ë¡ í•¨                        |
| ë™ì‘ ë°©ì‹          | ì°¸ì¡° ì¹´ìš´íŠ¸ë¥¼ ìœ ì§€í•˜ë©°, 0ì´ ë˜ë©´ ìë™ìœ¼ë¡œ ë©”ëª¨ë¦¬ í•´ì œ                 |
| clone()            | ì°¸ì¡° ì¹´ìš´íŠ¸ë§Œ ì¦ê°€, ì‹¤ì œ ë°ì´í„°ëŠ” ë³µì‚¬í•˜ì§€ ì•ŠìŒ                      |
| ì‚¬ìš© ì œí•œ          | ë‹¨ì¼ ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥ (`std::rc`)                         |
| ëŒ€í‘œ ì‚¬ìš© ì˜ˆ       | ê·¸ë˜í”„, íŠ¸ë¦¬, ê³µìœ  ë¦¬ìŠ¤íŠ¸ ë“± ë³µìˆ˜ ì°¸ì¡°ê°€ í•„ìš”í•œ êµ¬ì¡°                 |

--- 

# Weak / Arc<Mutex>

Rustì—ì„œ ìˆœí™˜ ì°¸ì¡°ë¥¼ ë°©ì§€í•˜ëŠ” Weak<T>, ê·¸ë¦¬ê³  ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ê³µìœ  ë°ì´í„°ë¥¼ ì•ˆì „í•˜ê²Œ ë‹¤ë£¨ëŠ” Arc<Mutex<T>> ì¡°í•©ì— ëŒ€í•´ ì •ë¦¬. 
ì´ ë‘ ê°œë…ì€ Rustì˜ ë©”ëª¨ë¦¬ ì•ˆì „ì„±ê³¼ ë™ì‹œì„± ëª¨ë¸ì„ ì´í•´í•˜ëŠ” ë° í•µì‹¬ì…ë‹ˆë‹¤.

## ğŸ§  1. Weak<T>ë¡œ ìˆœí™˜ ì°¸ì¡° ë°©ì§€í•˜ê¸°
### âœ… ì™œ í•„ìš”í•œê°€?
- Rc<T>ëŠ” ì°¸ì¡° ì¹´ìš´íŠ¸ë¥¼ ì¦ê°€ì‹œí‚¤ë©° ì†Œìœ ê¶Œì„ ê³µìœ í•©ë‹ˆë‹¤.
- í•˜ì§€ë§Œ ì„œë¡œê°€ ì„œë¡œë¥¼ ì°¸ì¡°í•˜ëŠ” êµ¬ì¡°(ì˜ˆ: ë¶€ëª¨-ìì‹ íŠ¸ë¦¬, ì–‘ë°©í–¥ ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸)ëŠ” ì°¸ì¡° ì¹´ìš´íŠ¸ê°€ 0ì´ ë˜ì§€ ì•Šì•„ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ë°œìƒí•©ë‹ˆë‹¤.

### âŒ ë¬¸ì œ ì˜ˆì‹œ
```rust
use std::rc::Rc;
use std::cell::RefCell;

struct Node {
    parent: RefCell<Option<Rc<Node>>>,
    children: RefCell<Vec<Rc<Node>>>,
}
```
- parentì™€ children ëª¨ë‘ Rc<Node>ë¥¼ ì‚¬ìš©í•˜ë©´ ìˆœí™˜ ì°¸ì¡° ë°œìƒ
- ì°¸ì¡° ì¹´ìš´íŠ¸ê°€ ì ˆëŒ€ 0ì´ ë˜ì§€ ì•Šì•„ dropì´ í˜¸ì¶œë˜ì§€ ì•ŠìŒ
###  âœ… í•´ê²° ë°©ë²•: Weak<T>
```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

struct Node {
    parent: RefCell<Weak<Node>>, // ğŸ” ì•½í•œ ì°¸ì¡°
    children: RefCell<Vec<Rc<Node>>>,
}
```

- Weak<T>ëŠ” ì°¸ì¡° ì¹´ìš´íŠ¸ë¥¼ ì¦ê°€ì‹œí‚¤ì§€ ì•ŠìŒ
- Rc::downgrade(&rc)ë¡œ ìƒì„±
- .upgrade()ë¥¼ í˜¸ì¶œí•˜ë©´ Option<Rc<T>>ë¡œ ì ‘ê·¼ ê°€ëŠ¥

### ğŸ§ª ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì—†ëŠ” íŠ¸ë¦¬ êµ¬ì¡°
```rust
let parent = Rc::new(Node { ... });
let child = Rc::new(Node { ... });

*child.parent.borrow_mut() = Rc::downgrade(&parent);
```

- parentëŠ” Rc, child.parentëŠ” Weak
- parentê°€ dropë˜ë©´ child.parent.upgrade()ëŠ” None ë°˜í™˜


## ğŸ§­ 2. Arc<Mutex<T>> ì¡°í•©ìœ¼ë¡œ ë©€í‹°ìŠ¤ë ˆë“œ ê³µìœ 
### âœ… ì™œ í•„ìš”í•œê°€?
- Rc<T>ëŠ” ë‹¨ì¼ ìŠ¤ë ˆë“œ ì „ìš©
- ë©€í‹°ìŠ¤ë ˆë“œì—ì„œ ë°ì´í„°ë¥¼ ê³µìœ í•˜ë ¤ë©´ ìŠ¤ë ˆë“œ ì•ˆì „í•œ Arc + Mutex ì¡°í•©ì´ í•„ìš”
### âœ… êµ¬ì¡°
```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));

    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap()); // Result: 10
}
```

- Arc<T>: ë©€í‹°ìŠ¤ë ˆë“œì—ì„œ ì†Œìœ ê¶Œ ê³µìœ 
- Mutex<T>: ë™ì‹œ ì ‘ê·¼ì„ ë§‰ê³  í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë§Œ ë°ì´í„° ìˆ˜ì • ê°€ëŠ¥
- .lock().unwrap()ìœ¼ë¡œ ë®¤í…ìŠ¤ ì ê¸ˆ í›„ ë°ì´í„° ì ‘ê·¼

## ğŸ§¬ Mermaidë¡œ ìˆœí™˜ ì°¸ì¡° êµ¬ì¡° ì‹œê°í™”
```mermaid
graph TD
    A[Parent Node] -->|Rc| B[Child Node]
    B -->|Weak| A
```

- A â†’ BëŠ” ê°•í•œ ì°¸ì¡° (Rc)
- B â†’ AëŠ” ì•½í•œ ì°¸ì¡° (Weak)
- ì´ êµ¬ì¡°ëŠ” ìˆœí™˜ ì°¸ì¡°ë¥¼ ë°©ì§€í•˜ë©´ì„œ ê´€ê³„ë¥¼ ìœ ì§€í•¨

## âœ… Weak<T> vs Arc<Mutex<T>> ìš”ì•½

| ê°œë…             | ëª©ì                                       | íŠ¹ì§•                                               |
|------------------|-------------------------------------------|----------------------------------------------------|
| `Weak<T>`        | ìˆœí™˜ ì°¸ì¡° ë°©ì§€                            | ì°¸ì¡° ì¹´ìš´íŠ¸ ì¦ê°€ ì—†ìŒ, `.upgrade()`ë¡œ ì ‘ê·¼ ê°€ëŠ¥     |
| `Arc<Mutex<T>>`  | ë©€í‹°ìŠ¤ë ˆë“œ ê³µìœ  + ë™ê¸°í™”                  | ìŠ¤ë ˆë“œ ì•ˆì „, ë°ì´í„° ë³´í˜¸, ìë™ ì ê¸ˆ í•´ì œ            |
| `Rc<T>`          | ë‹¨ì¼ ìŠ¤ë ˆë“œì—ì„œ ë³µìˆ˜ ì†Œìœ ê¶Œ               | ìˆœí™˜ ì°¸ì¡° ë°œìƒ ê°€ëŠ¥, `Weak<T>`ì™€ í•¨ê»˜ ì‚¬ìš© í•„ìš”     |

---



