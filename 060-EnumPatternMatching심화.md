# 패턴매칭 심화
튜플 패턴 매칭, 가드 조건(match guard), 그리고 패턴의 우선순위와 소모성까지 포함.

## 🧠 Match의 핵심 원리
Rust의 match는 단순한 switch 문이 아니라 패턴 기반 분기 시스템입니다.
다음과 같은 특징을 가집니다:
| 특징 항목             | 설명                                                                 |
|----------------------|----------------------------------------------------------------------|
| 패턴 기반 분기        | 값의 구조나 형태에 따라 분기 처리. 단순 값 비교를 넘어서 구조 분해 가능. |
| 데이터 추출 가능      | 패턴 내부의 값을 변수로 꺼내어 사용할 수 있음. 예: `Some(x)`에서 `x` 추출. |
| Exhaustive 처리       | 가능한 모든 경우를 반드시 처리해야 하며, 누락 시 컴파일 에러 발생.         |
| 우선순위 존재         | 위에서 아래로 순차적으로 평가되며, 첫 번째로 일치하는 패턴만 실행됨.       |
| catch-all 패턴        | `_`를 사용해 나머지 모든 경우를 처리 가능.                             |
| match guard (`if`)   | `if` 조건을 패턴에 추가하여 더 정교한 분기 처리 가능. 예: `x if x > 10`.   |


## 🔍 예제 ①: 튜플 패턴 매칭
```rust
fn sample(max: i32){
    for i in 0..=max {
        match (i % 3, i % 5) {
            (0, 0) => println!("i = {i}"),
            (0, _) => println!("i = {i}"),
            (_, _) => println!("i failed = {i}"),
        }
    }
}
```

### ✨ 분석
- match (i % 3, i % 5)는 튜플 패턴 매칭입니다.
- (0, 0)은 3과 5 모두 나누어 떨어질 때 (즉, 15의 배수)
- (0, _)은 3의 배수지만 5의 배수는 아닐 때
- (_, _)은 나머지 모든 경우 (catch-all)


### 📌 우선순위 중요:
i = 15일 때 (0, 0)이 먼저 매칭되므로 그 분기만 실행됨.
match는 첫 번째로 일치하는 패턴만 실행하고 종료됩니다.

## 🔍 예제 ②: match guard (if 조건)
```rust
for i in 1..=100 {
    let msg = match i {
        n if n % 15 == 0 => format!("{} - case 1", n),
        n if n % 3 == 0 => format!("{} - case 2", n),
        n if n % 5 == 0 => format!("{} - case 3", n),
        _ => format!("{}", i),
    };
    println!("{}", msg);
}
```

### ✨ 분석
- n if 조건은 match guard입니다.
- match는 i 값을 n에 바인딩하고, if 조건을 검사합니다.
- 조건이 참이면 해당 분기가 실행됩니다.
### 📌 우선순위 중요:
i = 15일 때 n % 15 == 0이 먼저 매칭되므로 "15 - case 1" 출력
i = 3일 때 "3 - case 2"
i = 5일 때 "5 - case 3"
그 외는 _로 처리

## 🧠 Match guard vs 일반 match
| 비교 항목               | 일반 match                                | match guard (`if`)                         |
|------------------------|--------------------------------------------|--------------------------------------------|
| 기본 문법               | `match x { 1 => ..., 2 => ... }`           | `match x { n if n > 10 => ... }`           |
| 조건 처리 방식          | 값 자체만 비교                             | 패턴에 `if` 조건을 추가하여 분기 처리       |
| 조건 키워드             | ❌ 없음                                    | ✅ `if` 사용                                |
| 변수 바인딩 방식        | `x => ...`                                 | `n if 조건 => ...`에서 `n`에 바인딩         |
| 표현력 및 유연성        | 제한적                                     | 조건 기반으로 더 정교한 분기 가능           |
| 사용 예시               | `match x { 3 => "Fizz", 5 => "Buzz" }`     | `match x { n if n % 3 == 0 => "Fizz" }`    |


## 예제
```rust
fn sample(max: i32){
    for i in 0..=max {
        match (i%3, i%5) {
            (0, 0) => println!("i = {i}"),
            (0, _) => println!("i = {i}"),
            (_, _) => println!("i failed = {i}"),
        }
    }
}

fn main() {
    sample(100);
}

fn main() {
    for i in 1..=100 {
        let msg = match i {
            n if n % 15 == 0 => format!("{} - case 1", n),
            n if n % 3 ==0 => format!("{} - case 2", n) ,
            n if n % 5 == 0 => format!("{} - case 3", n),
            _ => format!("{}", i)
        };
        println!("{}", msg);
    }
}


```


## 🔧 내부 동작 흐름 요약
- match는 입력값을 받아서 위에서 아래로 패턴을 비교합니다.
- 패턴이 일치하면 해당 분기를 실행하고 종료합니다.
- 패턴에 if 조건이 있으면, 조건까지 만족해야 실행됩니다.
- 모든 경우를 처리하지 않으면 컴파일 에러가 발생합니다.
- _는 catch-all로 나머지 모든 경우를 처리합니다.

## ✅ 실전 팁
- match는 패턴 + 조건 + 추출을 동시에 처리할 수 있는 강력한 도구입니다.
- match guard를 활용하면 if문 없이도 깔끔한 분기 처리가 가능합니다.
- match는 enum, Option, Result, 튜플, 구조체 등 거의 모든 타입에 적용 가능합니다.

---

