# 데이터 타입 정리

## 📌 Rust 정수 타입
| Length | Signed | Unsigned |
|--------|--------|----------|
| 8-bit  | i8     | u8       |
| 16-bit | i16    | u16      |
| 32-bit | i32    | u32      |
| 64-bit | i64    | u64      |
| arch   | isize  | usize    |

## 📌 Rust 숫자 리터럴
| Number literals | Example     |
|-----------------|-------------|
| Decimal         | 98_222      |
| Hex             | 0xff        |
| Octal           | 0o77        |
| Binary          | 0b1111_0000 |
| Byte (u8 only)  | b'A'        |

## 📌 숫자 리터럴 (한국어 표기)

##📖 Rust 데이터 타입 정리
- Rust에서 모든 값은 특정 데이터 타입의 값
-기본값: 스칼라(Scalar) 또는 복합값(Compound)
- Rust는 정적 타입 언어 → 컴파일 시점에 모든 변수의 타입이 결정되어야 함

## ✅ 정수(integer) 타입

- iN (signed) / uN (unsigned), N은 8·16·32·64 또는 arch(머신 워드 크기).
기본 정수형은 i32.

### 예:
```rust
fn main() {
    let guess: u32 = "42".parse().expect("Not a number!");
    println!("guess = {}", guess);
}
```

## ✅ 부동소수점(float) 타입

- f32 (32비트 부동소수점)
- f64 (64비트 부동소수점, 기본 타입)

### 예:
```rust
fn main() {
    let x = 2.0;       // f64
    let y: f32 = 3.0;  // f32
    println!("x = {}, y = {}", x, y);
}
```

## ✅ 정수 리터럴 예제
```rust
fn main() {
    let a = 19_384;        // 10진수
    let b = 0xff;          // 16진수
    let c = 0o77;          // 8진수
    let d = 0b1111_0010;   // 2진수
    let e = b'A';          // 바이트 (u8)

    println!("{a}-{b}-{c}-{d}-{e}");
}
```

### 출력:
```
19384-255-63-242-65
```

### 👉 숫자 리터럴에 **_(underscore)**를 명시적으로 써서 가독성을 높일 수 있음.
예: 1_000_000 (백만), 0b1010_1100.

## 🔍 보충할 점

리터럴 타입 접미사:
```rust
let x = 42u8;   // unsigned 8-bit
let y = 42i64;  // signed 64-bit
let z = 2.5f32; // 32-bit float
```

## 기본 타입 추론

정수: i32
부동소수점: f64
Byte 리터럴
'A'는 char (4바이트 유니코드)
b'A'는 u8 (1바이트)

## **스칼라(Scalar)** 와 복합(Compound)

| 구분       | 타입 종류        | 예시 코드                          | 설명 |
|------------|-----------------|-----------------------------------|------|
| **스칼라** | 정수 (integer)  | `let x: i32 = 10;`                | 부호 있는/없는 정수형 (`i8`, `u8`, …, `isize`, `usize`) |
|            | 부동소수점 (float) | `let y: f64 = 3.14;`              | `f32`, `f64`, 기본은 `f64` |
|            | 불리언 (bool)   | `let b: bool = true;`             | 참/거짓 값 (`true` / `false`) |
|            | 문자 (char)     | `let c: char = 'A';`              | 유니코드 스칼라 값, 4바이트 |
| **복합**   | 튜플 (tuple)    | `let t: (i32, f64, u8) = (500, 6.4, 1);` | 서로 다른 타입을 묶을 수 있음, 패턴 분해 가능 |
|            | 배열 (array)    | `let a: [i32; 3] = [1, 2, 3];`    | 고정 길이, 같은 타입 원소 |
|            | 슬라이스 (slice) | `let s: &[i32] = &a[0..2];`       | 배열/벡터의 연속 구간 참조 |
|            | 벡터 (Vec)      | `let v = vec![1, 2, 3];`          | 가변 길이 배열, 힙에 저장 |
|            | 문자열 (String) | `let s = String::from("hi");`     | 힙에 저장되는 가변 문자열 |
|            | 구조체 (struct) | `struct Point {x: i32, y: i32}`   | 필드 묶음, 사용자 정의 타입 |
|            | 열거형 (enum)   | `enum Color { Red, Green, Blue }` | 여러 선택지를 하나의 타입으로 |


## 📖 정리
- 스칼라 타입 → 단일 값 표현 (정수, 실수, 불리언, 문자).
- 복합 타입 → 여러 값을 묶어서 하나의 타입으로 표현 (튜플, 배열, 슬라이스, 벡터, 문자열, 구조체, 열거형 등).
- Rust는 정적 타입 언어이므로, 컴파일 시점에 모든 변수의 타입을 알아야 함.
---
