# 구조체 소유권
이 주제는 Rust의 핵심 철학인 **소유권(ownership)**과 **라이프타임(lifetime)**을 동시에 이해해야 하는 중요한 부분. 
구조체가 데이터를 직접 소유할 것인지, 아니면 참조만 할 것인지에 따라 설계 방식이 완전히 달라짐.

## 🧠 구조체의 데이터 소유권: String vs &str
### 🔹 String을 사용하는 경우
- 구조체가 데이터를 직접 소유함.
- 구조체가 유효한 동안 해당 데이터도 함께 살아 있음.
- 라이프타임 명시가 필요 없음 → 컴파일러가 자동으로 소유권을 추적.
```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}


let user1 = User {
    username: String::from("jhjeong"),
    email: String::from("junghwan.jeong@gmail.com"),
    sign_in_count: 1,
    active: true,
};

```

#### ✅ 이 방식은 가장 안전하고 직관적입니다. 구조체가 데이터를 소유하므로, 참조나 라이프타임 걱정 없이 사용 가능.

### 🔸 &str을 사용하는 경우
- 구조체는 데이터를 참조만 함 → 소유권 없음.
- 참조 대상이 구조체보다 먼저 해지되면 댕글링 참조 발생 위험.
- 따라서 라이프타임 명시가 필수.
```rust
struct User<'a> {
    username: &'a str,
    email: &'a str,
    sign_in_count: u64,
    active: bool,
}


let user1 = User {
    username: "jhjeong",
    email: "junghwan.jeong@gmail.com",
    sign_in_count: 1,
    active: true,
};
```

#### ✅ 이 방식은 메모리 사용을 줄이고 빠르게 처리할 수 있지만, 라이프타임을 정확히 관리해야 함.

#### 에러 발생
```rust
struct User {
    username: &str,
    email: &str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: "someone@example.com",
        username: "someusername123",
        active: true,
        sign_in_count: 1,
    };
}

```

##### 에러 메시지
```
error[E0106]: missing lifetime specifier
 --> src/main.rs:2:15
  |
2 |     username: &str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct User<'a> {
2 |     username: &'a str,

error[E0106]: missing lifetime specifier
 --> src/main.rs:3:12
  |
3 |     email: &str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct User<'a> {
2 |     username: &'a str,
3 |     email: &'a str,

```



### 🧭 언제 어떤 타입을 써야 할까?

| 상황                                 | 추천 타입 | 이유 또는 설명                                      | 라이프타임 필요 여부 |
|--------------------------------------|-----------|----------------------------------------------------|----------------------|
| 구조체가 데이터를 직접 소유해야 할 때 | `String`  | 구조체가 데이터의 소유권을 가지므로 안전함         | ❌ 필요 없음         |
| 외부 데이터를 임시로 참조할 때        | `&str`    | 메모리 절약, 빠른 처리 가능                        | ✅ 필요함            |
| 파싱된 텍스트를 구조체로 표현할 때    | `&str`    | 원본 데이터를 참조만 하고 복사하지 않음            | ✅ 필요함            |
| 장기 저장하거나 이동할 구조체일 때   | `String`  | 참조보다 소유가 안정적이며 라이프타임 관리 불필요  | ❌ 필요 없음         |


### 🔐 라이프타임이 필요한 이유
- 구조체가 참조를 포함하면, 참조 대상이 구조체보다 오래 살아야 함.
- Rust는 컴파일 시점에 모든 소유권과 수명 관계를 검사함.
- 라이프타임을 명시하면, 구조체와 참조 대상의 생존 관계를 명확히 표현할 수 있음.
```rust
#[derive(Debug)]
struct User<'a> {
    username: &'a str,
    email: &'a str,
    sign_in_count: u64,
    active: bool,
}
```

- 'a는 구조체가 참조하는 데이터가 적어도 구조체가 살아있는 동안 유효해야 함을 의미.

### ✅ 결론: 구조체 설계 시 `String` vs `&str`

| 선택    | 장점                                       | 단점                                       | 라이프타임 필요 여부 |
|---------|--------------------------------------------|--------------------------------------------|----------------------|
| `String` | 안전하고 라이프타임 걱정 없음              | 메모리 사용 증가, 복사 비용 발생 가능       | ❌ 필요 없음         |
| `&str`   | 메모리 절약, 빠른 처리 가능                | 라이프타임 관리 필요, 댕글링 참조 위험       | ✅ 필요함            |


Rust는 명시적이고 안전한 메모리 관리를 지향하기 때문에, 구조체 설계 시 소유권과 라이프타임을 함께 고려하는 것이 중요해요.
---
