# 함수에서 소유권 이전
Rust의 소유권 시스템은 안전성과 성능을 위해 설계된 강력한 개념이지만, 처음 접하면 꽤 복잡하게 느껴질 수 있음.  
아래에 함수 호출 시 소유권이 어떻게 이동하는지 핵심 개념과 예시를 정리.

## 🧭 함수 호출과 소유권 이동 요약

### 1. 소유권이 이동되는 경우 (Move)
- 힙에 저장되는 타입 (String, Vec, Box, 등)을 함수에 전달하면 소유권이 함수로 이동됨
- 원래 변수는 더 이상 사용할 수 없음
```rust
fn takes_ownership(s: String) {
    println!("{}", s);
}

fn main() {
    let s = String::from("hello");
    takes_ownership(s); // s는 더 이상 사용 불가
}
```


### 2. 복사되는 경우 (Copy)
- 스택에 저장되는 기본형 타입 (i32, bool, char, 등)은 Copy 트레잇이 구현되어 있어 값만 복사됨
- 원래 변수는 계속 사용 가능
```rust
fn makes_copy(x: i32) {
    println!("{}", x);
}

fn main() {
    let x = 5;
    makes_copy(x); // x는 여전히 유효
    println!("x = {}", x);
}
```


### 3. 함수 반환으로 소유권 회수
- 함수가 값을 반환하면 소유권이 호출한 쪽으로 다시 이동됨
```rust
fn gives_ownership() -> String {
    let s = String::from("hello");
    s // 소유권 반환
}

fn main() {
    let s1 = gives_ownership(); // s1이 소유권을 받음
}
```


### 4. 소유권을 넘겼다가 다시 받는 경우
- 인자로 받은 값을 반환하면 소유권을 다시 돌려받을 수 있음
```rust
fn takes_and_gives_back(s: String) -> String {
    s
}

fn main() {
    let s1 = String::from("hello");
    let s2 = takes_and_gives_back(s1); // s1 → 함수 → s2
}
```


### 5. 소유권을 잃고 복구하지 못하는 경우
- 함수가 값을 받아서 반환하지 않으면 소유권은 사라짐
```rust
fn string_length(s: String) {
    println!("{}", s.len());
}

fn main() {
    let s = String::from("hello");
    string_length(s);
    // println!("{}", s); // ❌ 컴파일 에러: s는 더 이상 유효하지 않음
}
```


### 6. 튜플로 소유권을 함께 반환하는 패턴
- 여러 값을 반환할 때 튜플을 사용하면 소유권을 함께 돌려줄 수 있음
```rust
fn string_length2(s: String) -> (usize, String) {
    let len = s.len();
    (len, s)
}

fn main() {
    let s = String::from("hello");
    let (len, s) = string_length2(s); // 소유권 복구
    println!("len = {}, s = {}", len, s);
}
```


## 🧩 개선 방향
단순히 문자열 길이를 구하는 함수 하나 때문에 소유권을 넘기고 다시 받아야 하는 구조는 번거롭습니다.

### 🔧 해결 방법: 참조 (&T) 사용
```rust
fn string_length(s: &String) -> usize {
    s.len()
}

fn main() {
    let s = String::from("hello");
    let len = string_length(&s); // 소유권을 넘기지 않음
    println!("len = {}, s = {}", len, s); // s는 여전히 유효
}
```

➡️ 참조를 사용하면 소유권을 넘기지 않고도 값을 읽을 수 있어 코드가 훨씬 간결해집니다.


##  전체 소스
```rust

//1. 소유권과 함수

fn main() {
    let s = String::from("hello"); // s가 스코프 안으로 들어왔습니다.
    takes_ownership(s); // s의 값이 함수 안으로 이동했습니다...
    // ... 그리고 s가 이제 더이상 유효하지 않습니다.                                            
    let x = 5; // x가 스코프 안으로 들어왔습니다.
    makes_copy(x); // x가 함수 안으로 이동했습니다만,
    // i32는 Copy가 되므로, x를 이후에 계속 사용해도 됩니다.
} // 여기서 x는 스코프 밖으로 나가고, s도 그 후 나갑니다. 하지만 s는 이미 이동되었으므로,
  // 별다른 일이 발생하지 않습니다.

fn takes_ownership(some_string: String) { // some_string이 스코프 안으로 들어왔습니다.
    println!("{}", some_string);
} // 여기서 some_string이 스코프 밖으로 벗어났고 `drop`이 호출됩니다. 메모리는 해제되었습니다.

fn makes_copy(some_integer: i32) { // some_integer이 스코프 안으로 들어왔습니다.
    println!("{}", some_integer);
} // 여기서 some_integer가 스코프 밖으로 벗어났습니다. 별다른 일은 발생하지 않습니다.



// 2. 반환 값과 스코프
//값의 반환 또한 소유권을 이동시킵니다.

fn main() {
    let s1 = gives_ownership(); // gives_ownership은 반환값을 s1에게
                                // 이동시킵니다.
    let s2 = String::from("hello"); // s2가 스코프 안에 들어왔습니다.
    let s3 = takes_and_gives_back(s2); // s2는 takes_and_gives_back 안으로
                                       // 이동되었고, 이 함수가 반환값을 s3으로도
                                       // 이동시켰습니다.
} // 여기서 s3는 스코프 밖으로 벗어났으며 drop이 호출됩니다. 
    //s2는 스코프 밖으로 벗어났지만 이동되었으므로 아무 일도 일어나지 않습니다. 
    //s1은 스코프 밖으로 벗어나서 drop이 호출됩니다.

  fn gives_ownership() -> String { // gives_ownership 함수가 반환 값을
                                   // 호출한 쪽으로 이동시킵니다.
    let some_string = String::from("hello"); // some_string이 스코프 안에 들어왔습니다.
    some_string                              // some_string이 반환되고, 호출한 쪽의
                                             // 함수로 이동됩니다.
}

// takes_and_gives_back 함수는 String을 하나 받아서 다른 하나를 반환합니다.
fn takes_and_gives_back(a_string: String) -> String { // a_string이 스코프 안으로 들어왔습니다.
    a_string  // a_string은 반환되고, 호출한 쪽의 함수로 이동됩니다.
}


//3. 소유권이 이전 되는 경우
fn string_length(s : String){
    println!("length = {}", s.len());
}
fn main() {
    let s = String::from("Hello");
    string_length(s);
}
//string_length가 불리면 s가 소유권을 잃는다.
fn main() {
    let s = String::from("Hello");
    string_length(s);
    //println!("s = {s}"); //Compile error
}


fn main() {
    let x = 3;
    double(x);
    println!("x = {x}"); //소유권 문제가 없다. 활용할 수 있다.
}
fn double(x : i32){
    println!("x = {x}");
}


//4. 함수 리턴값으로 소유권을 돌려 주는 경우
fn main() {
    let s = String::from("Hello");
    let s2 = string_length(s); //소유권이 다시 돌아 온다.
    println!("s2 = {s2}");
}
fn string_length(s: String) -> String {
    println!("s = {}", s.len());
    s
}

//5. 다른 리턴값을 되돌리면 함수로 넘어간 소유권은 해제된다.
fn main() {
    let s = String::from("Hello");
    let len = string_length(s); //스트링 길이가 넘어온다.
    println!("s length = {len}");
    //println!("s = {s}"); //소유권을 분실해서 쓸수가 없다.
}
fn string_length(s: String) -> usize {
    println!("s = {}", s);
    s.len()
}


//6. 튜플로 소유권을 넘겨 준다.
fn main() {
    let s = String::from("Hello");
    let (len, s) = string_length2(s); //소유권이 다시 돌아 온다.
    println!("s length = {len}");
    println!("s = {s}"); //소유권을 다시 돌려 받았으므로 쓸 수 있다.
}
//소유권을 위해서 튜풀을 이용한다.
fn string_length2(s: String) -> (usize, String) {
    println!("s = {}", s);
    (s.len(), s)
}
//개선이 필요하다.
//단순 스트링 길이를 구하는 함수를 호출 했을 뿐인데 소유권 문제 때문에 프로그램이 너무 복잡해 졌다.

```