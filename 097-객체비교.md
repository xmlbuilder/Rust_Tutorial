# Rust 객체 비교 (std::cmp::Ordering, std::cmp::Ord)
Rust에서 객체 간의 크기 비교를 다룰 때 사용하는 PartialOrd, Ord, 그리고 Ordering 타입에 대해 체계적으로 정리. 
Person 구조체와 정렬 로직은 실전에서도 매우 유용한 패턴.


## 🧠 핵심 개념 요약
| 트레이트 / 타입 | 주요 메서드 또는 값         | 설명                                 |
|------------------|-----------------------------|--------------------------------------|
| `PartialOrd`     | `partial_cmp()`             | 부분 순서 비교. `Option<Ordering>` 반환 |
| `Ord`            | `cmp()`                     | 전체 순서 비교. 항상 `Ordering` 반환   |
| `Ordering`       | `Less`, `Equal`, `Greater`  | 비교 결과를 나타내는 열거형 값         |

### 🧪 Ordering 타입
```rust
pub enum Ordering {
    Less,
    Equal,
    Greater,
}
```

- PartialOrd::partial_cmp() 또는 Ord::cmp()의 반환값
- match 또는 == 비교로 결과를 해석 가능

### ✨ PartialOrd 구현 예시
```rust
impl PartialOrd for Person {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        if self.height <= 0 || other.height <= 0 {
            return None;
        }
        Some(self.height.cmp(&other.height))
    }
}
```

- Option<Ordering>을 반환
- None은 비교 불가능한 경우 (예: 음수 키)
- cmp()는 Ord 트레이트의 메서드지만 i32는 이미 Ord를 구현하고 있어 사용 가능

### 샘플 코드
```rust
use std::cmp::Ordering;

#[derive(PartialEq, Eq)]
struct Person {
    name: String,
    age: i32,
    height: i32
}

impl PartialOrd for Person {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        if self.height <= 0 || other.height <= 0 {
            return None;
        }
        if self.height > other.height {
            Some(Ordering::Greater)
        }
        else if self.height < other.height {
            Some(Ordering::Less)
        }
        else{
            Some(Ordering::Equal)
        }
    }
}

fn main(){
    let alpha = Person{
        name: "alpha".to_owned(),
        age: 10,
        height: 130,
    };
    let beta = Person{
        name: "beta".to_owned(),
        age: 10,
        height: 100,
    };
    if alpha > beta {
        println!("{} is taller.", alpha.name);
    }
    if alpha.partial_cmp(&beta).unwrap() == Ordering::Greater {
        println!("{} is taller", alpha.name);
    }
}
```

## ✅ Ord 트레이트와 자동 정렬
Ord는 PartialOrd와 Eq를 기반으로 하며, cmp() 메서드를 구현해야 합니다.
단, Ord는 전체 순서를 요구하므로 None을 반환할 수 없습니다.
```rust
impl Ord for Person {
    fn cmp(&self, other: &Self) -> Ordering {
        self.height.cmp(&other.height)
    }
}
```

그리고 #[derive(PartialEq, Eq, PartialOrd, Ord)]를 사용하면 자동으로 멤버 순서에 따라 비교가 구현됩니다.

## 🔁 정렬 함수 예시
### 직접 구현한 버블 정렬
```rust
fn class_sorting(peoples: &mut Vec<Person>) {
    let len = peoples.len();
    for i in 0..(len - 1) {
        for j in (i + 1)..len {
            if peoples[i] > peoples[j] {
                peoples.swap(i, j);
            }
        }
    }
}
```

### 표준 라이브러리 정렬
```rust
peoples.sort_by(|a, b| a.partial_cmp(b).unwrap());

```
- sort_by()는 Ordering을 반환하는 클로저를 요구
- unwrap()은 None이 발생하지 않는다는 전제 하에 사용

### 전체 소스
```rust
use std::cmp::Ordering;
#[derive(PartialEq, Eq, Debug)]
struct Person {
    name: String,
    age: i32,
    height: i32
}
impl PartialOrd for Person {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        if self.height <= 0 || other.height <= 0 {
            return None;
        }
        if self.height > other.height {
            Some(Ordering::Greater)
        }
        else if self.height < other.height {
            Some(Ordering::Less)
        }
        else{
            Some(Ordering::Equal)
        }
    }
}
fn class_sorting(peoples: &mut Vec<Person>){
    let len = peoples.len();
    for i in 0..(len-1) {
        for j in (i+1)..len {
            if peoples[i] > peoples[j]
            {
                peoples.swap(i, j);
            }
        }
    }
}
fn main(){
    let mut peoples = vec![
        Person{
            name: "aaa".to_owned(),
            age: 10,
            height: 130,
        },
        Person{
            name: "bbb".to_owned(),
            age: 10,
            height: 100,
        },
        Person{
            name: "ccc".to_owned(),
            age: 10,
            height: 170,
        },
    ];
    class_sorting(&mut peoples);
    for p in peoples.iter(){
        println!("people {:?}", p)
    }
// people Person { name: "bbb", age: 10, height: 100 }
// people Person { name: "aaa", age: 10, height: 130 }
// people Person { name: "ccc", age: 10, height: 170 }
}




use std::cmp::Ordering;
#[derive(PartialEq, Eq, Debug)]
struct Person {
    name: String,
    age: i32,
    height: i32
}
impl PartialOrd for Person {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        if self.height <= 0 || other.height <= 0 {
            return None;
        }
        if self.height > other.height {
            Some(Ordering::Greater)
        }
        else if self.height < other.height {
            Some(Ordering::Less)
        }
        else{
            Some(Ordering::Equal)
        }
    }
}

fn class_sorting(peoples: &mut Vec<Person>){
    let len = peoples.len();
    for i in 0..(len-1) {
        for j in (i+1)..len {
            if peoples[i] > peoples[j]
            {
                peoples.swap(i, j);
            }
        }
    }
}
fn main(){
    let mut peoples = vec![
        Person{
            name: "aaa".to_owned(),
            age: 10,
            height: 130,
        },
        Person{
            name: "bbb".to_owned(),
            age: 10,
            height: 100,
        },
        Person{
            name: "ccc".to_owned(),
            age: 10,
            height: 170,
        },
    ];
    class_sorting(&mut peoples);
    for p in peoples.iter(){
        println!("people {:?}", p)
    }


// people Person { name: "bbb", age: 10, height: 100 }
// people Person { name: "aaa", age: 10, height: 130 }
// people Person { name: "ccc", age: 10, height: 170 }

    peoples.sort_by(|a, b| a.partial_cmp(b).unwrap());
    for p in peoples.iter(){
        println!("people {:?}", p)
    }
// people Person { name: "bbb", age: 10, height: 100 }
// people Person { name: "aaa", age: 10, height: 130 }
// people Person { name: "ccc", age: 10, height: 170 }    
}


```


⚠️ 주의 사항

| 항목        | 설명 또는 주의할 점                                      |
|-------------|----------------------------------------------------------|
| `PartialOrd` | `sort()` 사용 불가. 대신 `sort_by()` 또는 `sort_unstable_by()` 사용 |
| `Ord` + `None` | `Ord::cmp()`은 `None`을 반환할 수 없음. 항상 `Ordering` 반환 필요 |
| `unwrap()`   | `partial_cmp()` 결과가 `None`일 수 있으므로 `unwrap()`은 위험. `match`로 안전하게 처리 권장 |

---






