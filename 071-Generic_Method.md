# 🧠 Generic Method란?
제네릭 메서드는 구조체나 열거형에 정의된 메서드가 제네릭 타입 파라미터를 사용하여 다양한 타입에 대해 동작할 수 있도록 하는 기능입니다.  
구조체 자체가 제네릭일 경우, 그 타입 파라미터를 그대로 메서드에서도 사용할 수 있습니다.

## 🧱 코드 요약
```rust
#[derive(Debug)]
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    println!("p1.x() = {}", p1.x());
}
```


## ✅ 핵심 포인트
- Point<T>는 제네릭 구조체로 x, y가 같은 타입 T를 가짐
- impl<T> 블록에서 T를 사용해 메서드 정의 가능
- x() 메서드는 self.x의 참조를 반환하며, 타입은 &T


## ⚠️ Generic Method 사용 시 주의사항
| 항목               | 설명                                                                 |
|--------------------|----------------------------------------------------------------------|
| 타입 일치 필요     | `Point<T>`는 `x`, `y`가 동일한 타입이어야 함 (`i32`, `f64` 등)         |
| 제네릭 메서드 정의 | `impl<T>` 블록에서 `T`를 그대로 사용하여 메서드 정의 가능               |
| 반환 타입 명시     | 메서드에서 `&T`처럼 반환 타입도 제네릭으로 지정해야 타입 추론이 정확함   |
| 디버그 출력        | `println!("{:?}")` 사용 시 `#[derive(Debug)]`가 필요                     |


## 💡 확장 아이디어
- 다른 필드(y)를 반환하는 메서드도 쉽게 추가 가능
- impl<T: Display>처럼 트레이트 바운드를 걸어 특정 기능을 가진 타입만 허용 가능
- impl<T, U> Point<T, U>처럼 다중 제네릭 구조체에도 메서드 정의 가능

## 🧩 예시: 트레이트 바운드가 있는 제네릭 메서드
```rust
use std::fmt::Display;

impl<T: Display> Point<T> {
    fn show_x(&self) {
        println!("x = {}", self.x);
    }
}
```

→ T가 Display를 구현한 타입일 때만 show_x() 메서드 사용 가능
---
