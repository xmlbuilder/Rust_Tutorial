# 🧠 Rust vs C++ 메모리 관리 비교
| **항목**               | **Rust**                                                                 | **C++**                                                                 |
|------------------------|--------------------------------------------------------------------------|------------------------------------------------------------------------|
| 메모리 관리 방식        | **소유권(Ownership)** + **빌림(Borrowing)** + **라이프타임(Lifetime)** | **수동 관리** + **스마트 포인터** + **RAII**                          |
| 메모리 해제 시점        | 컴파일러가 자동으로 결정 (`drop` 호출)                                  | 개발자가 직접 `delete` 호출하거나 스마트 포인터 사용                  |
| 런타임 비용             | 없음 (컴파일 시점에 검증)                                               | 있음 (런타임에 메모리 해제 및 예외 처리 발생 가능)                    |
| 안전성                 | Null, Dangling Pointer, Data Race 방지                                  | Null, Dangling Pointer, Memory Leak 발생 가능                         |
| 에러 발생 시점         | **컴파일 시점**에 오류 발생                                             | 대부분 **런타임**에 오류 발생                                          |
| 스마트 포인터          | `Box`, `Rc`, `Arc`, `RefCell` 등                                       | `unique_ptr`, `shared_ptr`, `weak_ptr` 등                              |
| 가비지 컬렉션          | 없음 (명시적 소유권 모델로 대체)                                        | 없음 (일부 구현에서 Boehm GC 사용 가능)                               |
| 병행성 지원            | `Send`, `Sync` trait 기반 안전한 병행성                                 | 병행성은 개발자 책임, race condition 발생 가능                         |



## 🔍 Rust의 핵심 개념 요약
- 소유권(Ownership): 모든 값은 하나의 소유자만 가질 수 있으며, 소유자가 스코프를 벗어나면 자동으로 메모리가 해제됩니다.
- 빌림(Borrowing): 값을 참조할 수 있지만, 동시에 여러 mutable 참조는 허용되지 않아 데이터 경쟁을 방지합니다.
- 라이프타임(Lifetime): 참조가 유효한 범위를 명시적으로 지정하여 dangling pointer를 방지합니다.
Rust는 “규칙을 잘 지키면 컴파일러가 알아서 처리해준다”는 철학을 따릅니다. 실수할 여지가 없고, 실행 시간에 손해도 없음.


## 🔍 C++의 핵심 개념 요약
- 수동 메모리 관리: new로 할당하고 delete로 해제해야 하며, 실수 시 메모리 누수 발생 가능.
- RAII (Resource Acquisition Is Initialization): 객체의 생성과 소멸 시점에 자원을 자동으로 관리하는 패턴.
- 스마트 포인터: unique_ptr, shared_ptr 등으로 자동 해제를 지원하지만, 순환 참조나 복잡한 소유권 구조는 여전히 위험 요소.
C++은 자유도가 높지만, 그만큼 개발자의 책임도 큽니다. 메모리 누수, 이중 해제, dangling pointer 등은 여전히 흔한 버그입니다.



