# 소유권 관련 
Rust의 소유권 돌려주기, 가변 참조자(borrowing), 그리고 클로저에서의 빌림 충돌에 대해 핵심.

## 🔁 소유권 돌려주기 (Ownership Return)
Rust에서는 값을 함수에 넘기면 소유권이 이동합니다.
만약 함수가 그 값을 다시 사용하게 하려면, **반환(return)**을 통해 소유권을 돌려줘야 합니다.
```rust
fn take_ownership(some_string: String) -> String {
    println!("{}", some_string);
    some_string // 소유권을 반환
}

fn main() {
    let s1 = String::from("hello");
    let s2 = take_ownership(s1); // s1의 소유권이 함수로 이동
    println!("{}", s2);          // s2가 소유권을 이어받음
}
```

✅ 요점: 값을 함수에 넘기고 나서 다시 쓰려면, 함수가 값을 반환해야 합니다.

## 🔧 빌림(Borrowing)으로 소유권 유지
소유권을 넘기지 않고 값을 수정하려면 가변 참조자를 사용합니다.
```rust
fn borrow_objects(s: &mut String){
    println!("{}", s);
    s.push_str("World"); // 값 수정 가능
}

fn main() {
    let mut s = String::from("Hello, ");
    borrow_objects(&mut s); // 소유권은 유지, 값은 수정됨
    println!("{}", s);      // Hello, World
}
```

✅ 요점: &mut T를 사용하면 소유권 없이 값을 수정할 수 있습니다.

## 🧠 클로저에서의 빌림 충돌
클로저는 캡처한 변수에 대해 **자동으로 빌림(borrow)**을 수행합니다.
가변 참조는 동시에 하나만 가능하므로, 아래 예제는 컴파일 에러가 발생합니다.
```rust
fn main() {
    let mut name = "1".to_string();

    let mut inc1 = || {
        name.push_str("2"); // 첫 번째 가변 참조
        println!("name: {}", name);
    };
    inc1();

    let mut inc2 = || {
        name.push_str("3"); // 두 번째 가변 참조
        println!("name: {}", name);
    };
    inc2(); // ✅ 여기까지는 괜찮음

    // inc1(); // ❌ 다시 호출하면 첫 번째 참조가 아직 살아있다고 판단 → 에러 발생
}
```

### 에러 메시지
```
    error[E0499]: cannot borrow `name` as mutable more than once at a time
  --> src/main.rs:14:20
   |
7  |     let mut inc1 = || {
   |                    -- first mutable borrow occurs here
8  |         name.push_str("2");
   |         ---- first borrow occurs due to use of `name` in closure
...
14 |     let mut inc2 = || {
   |                    ^^ second mutable borrow occurs here
15 |         name.push_str("3");
   |         ---- second borrow occurs due to use of `name` in closure
...
21 |     inc1();
   |     ---- first borrow later used here
```

### 🛑 에러 메시지 요약:
- name을 inc1에서 가변 참조했기 때문에, inc2에서 또 가변 참조하면 충돌
- Rust는 런타임이 아닌 컴파일 타임에 이런 충돌을 감지하여 방지함

## ✅ 핵심 요약 표 (Markdown)
| 개념               | 설명                                                                 |
|--------------------|----------------------------------------------------------------------|
| 소유권 이동         | 함수에 값 전달 시 소유권이 이동함                                     |
| 소유권 반환         | 값을 다시 사용하려면 함수에서 반환해야 함                              |
| 불변 참조 (`&T`)    | 읽기만 가능, 여러 개 허용                                              |
| 가변 참조 (`&mut T`)| 쓰기 가능, 단 하나만 허용                                              |
| 클로저의 빌림       | 클로저는 변수 캡처 시 자동으로 빌림 수행                               |
| 빌림 충돌 방지      | 동시에 여러 가변 참조 불가 → 컴파일 타임에 에러 발생                    |

----



