# 🧠 Rust vs C++ 메모리 해제 비교
| **항목**             | **Rust**                                                                 | **C++**                                                                 |
|----------------------|--------------------------------------------------------------------------|------------------------------------------------------------------------|
| 메모리 해제 시점      | **스코프 종료 시 자동 해제** (`Drop` 트레이트 호출)                     | **소멸자 호출 + 명시적 해제** (`delete`, `delete[]`)                   |
| 해제 방식            | 컴파일러가 `drop()` 호출하여 자원 정리                                 | 개발자가 `delete` 또는 스마트 포인터 사용                             |
| 안전성               | 컴파일 시점에 소유권/라이프타임 검사로 안전성 확보                      | 런타임에 오류 발생 가능 (이중 해제, 누수, dangling pointer 등)         |
| 예제에서의 동작      | 블록이 끝나면 `drop()` 자동 호출                                         | 블록이 끝나도 `new`로 할당한 메모리는 자동 해제되지 않음              |
| 커스터마이징         | `Drop` 트레이트 구현으로 해제 시 동작 정의 가능                         | 소멸자(`~ClassName()`) 정의로 해제 시 동작 지정 가능                   |
| 스마트 포인터 지원   | `Box`, `Rc`, `Arc` 등으로 힙 메모리 안전하게 관리                       | `unique_ptr`, `shared_ptr` 등으로 자동 해제 지원                       |



## 🔍 Rust 예제 설명

```rust
struct MyStruct {}

impl Drop for MyStruct {
    fn drop(&mut self) {
        println!("Dropping MyStructure now!");
    }
}
```

- Drop 트레이트는 Rust에서 자원 해제를 위한 인터페이스입니다.
- let my2 = MyStruct{}는 inner block에서 생성되며, 블록이 끝나는 순간 drop()이 자동 호출됩니다.
- my1은 main 함수가 끝날 때 해제됩니다.
💡 Rust는 소유권 모델 덕분에 메모리 해제를 명시적으로 하지 않아도 안전하게 처리됩니다.


## 🔍 C++에서의 대응 방식
```cpp
class MyStruct {
public:
    ~MyStruct() {
        std::cout << "Dropping MyStructure now!" << std::endl;
    }
};

int main() {
    std::cout << "main start" << std::endl;

    MyStruct my1;
    {
        std::cout << "inner block start" << std::endl;
        MyStruct my2;
        std::cout << "inner block end" << std::endl;
    }

    std::cout << "main end" << std::endl;
}
```

- 위 예제는 스택에 할당된 객체이므로 블록 종료 시점에 소멸자가 자동 호출됩니다.
- 하지만 new MyStruct()로 힙에 할당한 경우에는 delete를 명시적으로 호출해야 해제됩니다.
MyStruct* ptr = new MyStruct();
delete ptr; // 소멸자 호출 + 메모리 해제


💡 C++은 RAII 패턴을 통해 스택 객체는 안전하게 관리되지만, 힙 객체는 개발자가 직접 관리해야 합니다.


## 🧩 요약
- Rust는 컴파일러가 메모리 해제를 자동으로 처리하며, 실수할 여지가 거의 없습니다.
- C++은 개발자가 메모리 해제를 직접 관리해야 하며, 실수로 인한 버그가 발생할 수 있습니다.
- Rust의 Drop은 C++의 소멸자와 유사하지만, 소유권 모델과 함께 작동하여 훨씬 더 안전한 메모리 관리가 가능합니다.


